<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统 - Lab1 | qwqbot</title><meta name="author" content="qwqbot"><meta name="copyright" content="qwqbot"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ucore-Lab1">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 - Lab1">
<meta property="og:url" content="http://qwqbot.com/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Lab1/index.html">
<meta property="og:site_name" content="qwqbot">
<meta property="og:description" content="ucore-Lab1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359">
<meta property="article:published_time" content="2021-03-24T00:41:07.340Z">
<meta property="article:modified_time" content="2021-04-03T01:37:38.192Z">
<meta property="article:author" content="qwqbot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359"><link rel="shortcut icon" href="/img/qwq_circle2.jpg"><link rel="canonical" href="http://qwqbot.com/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Lab1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-03 09:37:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/qwq_circle2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qwqbot</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统 - Lab1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-24T00:41:07.340Z" title="发表于 2021-03-24 08:41:07">2021-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-03T01:37:38.192Z" title="更新于 2021-04-03 09:37:38">2021-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/">CS0804n</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/">实验</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Lab1 系统软件的启动过程</h1>
<h2 id="实验目的">实验目的</h2>
<p>操作系统是一个软件, 也需要通过某种机制加载并运行它. 在这里我们将通过另外一个更加简单的软件-bootloader来完成这些工作. 为此, 我们需要完成一个能够切换到x86的保护模式并显示字符的bootloader, 为启动操作系统ucore做准备. lab1提供了一个非常小的bootloader和ucore OS, 整个bootloader执行代码小于512个字节, 这样才能放到硬盘的主引导扇区中. 通过分析和实现这个bootloader和ucore OS, 我们可以了解到：</p>
<ul>
<li>
<p>计算机原理</p>
<ul>
<li>
<p>CPU的编址与寻址: 基于分段机制的内存管理</p>
</li>
<li>
<p>CPU的中断机制</p>
</li>
<li>
<p>外设：串口/并口/CGA，时钟，硬盘</p>
</li>
</ul>
</li>
<li>
<p>Bootloader软件</p>
<ul>
<li>编译运行bootloader的过程</li>
<li>调试bootloader的方法</li>
<li>PC启动bootloader的过程</li>
<li>ELF执行文件的格式和加载</li>
<li>外设访问：读硬盘, 在CGA上显示字符串 ucore OS软件</li>
</ul>
</li>
<li>
<p>编译运行ucore OS的过程</p>
<ul>
<li>ucore OS的启动过程</li>
<li>调试ucore OS的方法</li>
<li>函数调用关系：在汇编级了解函数调用栈的结构和处理过程</li>
<li>中断管理：与软件相关的中断处理</li>
<li>外设管理：时钟</li>
</ul>
</li>
</ul>
<h3 id="bootloader是什么">bootloader是什么</h3>
<p><strong>[<strong>参考 <a target="_blank" rel="noopener" href="https://www.ionos.com/digitalguide/server/configuration/what-is-a-bootloader">“Bootloader: What you need to know about the system boot manager”</a></strong>]</strong></p>
<blockquote>
<p>Bootloader is a piece of code/program that runs before an operating system starts to run. It loads an operating system when a computer is turned on. It tells the hardware where to look and how to get running when you start things up.</p>
</blockquote>
<p>bootloader是硬件和操作系统之间的中介.</p>
<p>在运行操作系统前, 需要把其装载到RAM中. bootloader就是用来把操作系统从磁盘中装到RAM中, 然后把控制权移交给操作系统的软件.</p>
<p>bootloader通常在放在硬盘的第一个扇区, 该扇区又叫 boot block 或 boot sector. 然后通过硬件来启动bootloader完成相应功能.</p>
<h2 id="实验内容">实验内容</h2>
<p>lab1中包含一个bootloader和一个OS. 这个bootloader可以切换到X86保护模式, 能够读磁盘并加载ELF执行文件格式, 并显示字符. 而这lab1中的OS只是一个可以处理时钟中断和显示字符的幼儿园级别OS.</p>
<h3 id="练习1-理解通过make生成执行文件的过程">练习1 理解通过make生成执行文件的过程</h3>
<ul>
<li>
<p>练习要求</p>
<p>在此练习中，需要通过静态分析代码来了解：</p>
<ol>
<li>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命<br>
令参数的含义，以及说明命令导致的结果)</li>
<li>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</li>
</ol>
</li>
<li>
<p>参考资料</p>
<ol>
<li>
<p><strong>makefile中文文档</strong>        https://seisman.github.io/how-to-write-makefile/introduction.html</p>
</li>
<li>
<p><strong>Makefile教程:Makefile文件编写1天入门</strong>	http://c.biancheng.net/makefile/</p>
</li>
<li>
<p><strong>Linux编译工具：gcc入门 - 明澈的文章 - 知乎</strong>	https://zhuanlan.zhihu.com/p/76930507</p>
</li>
</ol>
</li>
<li>
<p>.s和.S的区别</p>
<p>.S在经过汇编器汇编之前还会有预处理过程. 所以可以在其中加入预处理语句.</p>
</li>
</ul>
<h4 id="img文件生成过程">img文件生成过程</h4>
<h5 id="编译过程">编译过程</h5>
<p>首先进入 ~/moocos/ucore_lab/labcodes/lab1 文件夹中. 输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make V=</span><br></pre></td></tr></table></figure>
<p>获得编译过程.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">kern/init/init.c:95:1: warning: ‘lab1_switch_test’ defined but not used [-Wunused-function]</span><br><span class="line"> lab1_switch_test(void) &#123;</span><br><span class="line"> ^</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line"></span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line"></span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">kern/debug/kdebug.c:251:1: warning: ‘read_eip’ defined but not used [-Wunused-function]</span><br><span class="line"> read_eip(void) &#123;</span><br><span class="line"> ^</span><br><span class="line"> </span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line"></span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/trap.c</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o</span><br><span class="line">kern/trap/trap.c:14:13: warning: ‘print_ticks’ defined but not used [-Wunused-function]</span><br><span class="line"> static void print_ticks() &#123;</span><br><span class="line">             ^</span><br><span class="line">kern/trap/trap.c:30:26: warning: ‘idt_pd’ defined but not used [-Wunused-variable]</span><br><span class="line"> static struct pseudodesc idt_pd = &#123;</span><br><span class="line">                          ^</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/trapentry.S</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/vectors.S</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o</span><br><span class="line"></span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line"></span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line"></span><br><span class="line">+ cc libs/string.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line"></span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br><span class="line"></span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line"></span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"></span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line"></span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">&#x27;obj/bootblock.out&#x27; size: 472 bytes</span><br><span class="line"></span><br><span class="line">build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0187377 s, 273 MB/s</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.5527e-05 s, 6.0 MB/s</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line">138+1 records in</span><br><span class="line">138+1 records out</span><br><span class="line">70775 bytes (71 kB) copied, 0.000266882 s, 265 MB/s</span><br></pre></td></tr></table></figure>
<p>解读一下这些命令.</p>
<p>首先是 <strong>cc</strong> 命令</p>
<ul>
<li>
<p><strong>-fno-builtin</strong></p>
<p>不承认不以 __builtin_ 开头的内置函数. 可以用来避免命名冲突.</p>
</li>
<li>
<p><strong>-Wall</strong></p>
<p>报错</p>
</li>
<li>
<p><strong>-ggdb</strong></p>
<p>基本等于 -g. 生成调试信息</p>
</li>
<li>
<p><strong>-m32</strong></p>
<p>生成32位的程序. 即long, pointer都是32bit的</p>
</li>
<li>
<p><strong>-gstabs</strong></p>
<p>Produce debugging information in stabs format</p>
</li>
<li>
<p><strong>-Idir</strong></p>
<p>指定头文件搜索目录. gcc会先在你指定的目录寻找, 再到默认路径寻找</p>
</li>
<li>
<p><strong>-nostdinc</strong></p>
<p>ignores standard C include directories</p>
</li>
<li>
<p><strong>-c</strong></p>
<p>生成.o的目标文件, 不进行链接过程</p>
</li>
<li>
<p><strong>-o</strong></p>
<p>指定目标文件的名字. 不是生成可执行文件的意思..</p>
</li>
<li>
<p><strong>-fno-stack-protector</strong></p>
<p>关闭栈保护机制.</p>
</li>
</ul>
<p>然后是 <strong>ld</strong> 命令</p>
<ul>
<li>
<p><strong>-m elf_i386</strong></p>
<p>模拟elf_i386链接器</p>
</li>
<li>
<p><strong>-nostdlib</strong></p>
<p>不链接标准库.</p>
</li>
<li>
<p><strong>-N</strong></p>
<p>Set the text and data sections to be readable and writable.</p>
</li>
<li>
<p><strong>-e</strong></p>
<p>设置函数初始执行位置.</p>
</li>
<li>
<p><strong>-T</strong></p>
<p>指明链接脚本,链接脚本是用来指明各个段的位置还有入口之类的链接信息的.</p>
</li>
<li>
<p><strong>-Ttext 0x7c00</strong></p>
<p>指定代码text段在内存中的位置.</p>
</li>
<li>
<p><strong>-o</strong></p>
<p>指明文件名称</p>
</li>
</ul>
<p><strong>dd</strong> 命令, 这个是linux用来读取转换并输出数据的命令</p>
<ul>
<li>
<p>if = 文件名</p>
<p>输入文件名</p>
</li>
<li>
<p>of = 文件名</p>
<p>输出文件名</p>
</li>
<li>
<p>bs=bytes</p>
<p>同时设置读入/输出的块大小为bytes个字节.默认512</p>
</li>
<li>
<p>seek = blocks<br>
输出文件开始跳过blocks块再复制</p>
</li>
<li>
<p>count = blocks</p>
<p>拷贝blocks个块</p>
</li>
<li>
<p>conv = notrunc</p>
<p>不截断输出文件</p>
</li>
</ul>
<p>为了更好的分析项目中的文件依赖关系, 在网上找了一张项目依赖图.(来自 https://xr1s.me/2018/05/15/ucore-lab1-report/)</p>
<p><img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/ucore-lab1-dependency-tree.png" alt="lab1 Makefile 依赖图"></p>
<h5 id="阅读makefile">阅读makefile</h5>
<p>首先来到代码178行, 定义了 ucore.img的生成过程</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create ucore.img</span></span><br><span class="line">UCOREIMG	:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span> <span class="comment">#这里的totarget应该就是生成ucore.img的函数. </span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span>       <span class="comment">#两个依赖项</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000 <span class="comment">#命令前加 @, 只显示结果不会显示命令本身</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br></pre></td></tr></table></figure>
<p>上面的命令就是之前看到的.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000 #先从空白区写入5120000</span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0187377 s, 273 MB/s</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc #把bootblock放到第一个扇区</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.5527e-05 s, 6.0 MB/s</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc #把kernel放到第二个之后的扇区</span><br><span class="line">138+1 records in</span><br><span class="line">138+1 records out</span><br><span class="line">70775 bytes (71 kB) copied, 0.000266882 s, 265 MB/s</span><br></pre></td></tr></table></figure>
<p>它有两个依赖项. kernel 和 bootblock</p>
<p>140行的kernel</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create kernel target</span></span><br><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span></span><br></pre></td></tr></table></figure>
<p>然后这个totarget函数是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">totarget = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BINDIR)</span><span class="variable">$(SLASH)</span>,$(1)</span>)</span><br></pre></td></tr></table></figure>
<p>而 addprefix函数就是一个给文件加前缀的东西</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(addperfix &lt;prefix&gt;,&lt;names&gt;)</span></span><br><span class="line"><span class="comment"># 把prefix加到names的每个单词前面, 返回值为添加完的单词序列</span></span><br><span class="line">BINDIR  := bin</span><br><span class="line">SLASH   := /</span><br></pre></td></tr></table></figure>
<p>所以说totarget函数就是给文件加上 “bin/“ 这个prefix</p>
<p>然后再看一下kernel的依赖</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KOBJS	= <span class="variable">$(<span class="built_in">call</span> read_packet,kernel libs)</span></span><br><span class="line">read_packet = <span class="variable">$(<span class="built_in">foreach</span> p,$(<span class="built_in">call</span> packetname,$(1)</span>),$(<span class="variable">$(p)</span>))</span><br></pre></td></tr></table></figure>
<p>这个foreach函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 把list中的每个变量取出来, 然后把它看成var, 最后执行text, </span></span><br><span class="line"></span><br><span class="line">name:=a b c d</span><br><span class="line">files:=<span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(files)</span></span><br><span class="line"><span class="comment"># 得到 a.o b.o c.o d.o</span></span><br></pre></td></tr></table></figure>
<p>然后其中的packetname函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">packetname = <span class="variable">$(<span class="built_in">if</span> $(1)</span>,<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="variable">$(OBJPREFIX)</span>)	</span><br><span class="line">OBJPREFIX	:= __objs_</span><br></pre></td></tr></table></figure>
<p>这个 if 函数也很好理解..</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span> </span><br><span class="line">$(if&lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span><br></pre></td></tr></table></figure>
<p>所以packetname函数就是一个加前缀的.</p>
<p>所以KOBJS就是一堆从kernel libs读出来的文件.</p>
<p>gccprefix 差不多就是一个确认i386-elf存在 然后返回这个前缀的东西</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to infer the correct GCCPREFX</span></span><br><span class="line"><span class="keyword">ifndef</span> GCCPREFIX</span><br><span class="line">GCCPREFIX := <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> i386-elf-objdump -i 2&gt;&amp;1 | grep &#x27;^elf32-i386$$&#x27; &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">	then echo &#x27;i386-elf-&#x27;; \</span></span><br><span class="line"><span class="variable">	elif objdump -i 2&gt;&amp;1 | grep &#x27;elf32-i386&#x27; &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">	then echo &#x27;&#x27;; \</span></span><br><span class="line"><span class="variable">	else echo &quot;***&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** Error: Couldn&#x27;t find an i386-elf version of GCC/binutils.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** Is the directory with i386-elf-gcc in your PATH?&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** If your i386-elf toolchain is installed with a command&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** prefix other than &#x27;i386-elf-&#x27;, set your GCCPREFIX&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** environment variable to that prefix <span class="built_in">and</span> run &#x27;make&#x27; again.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;*** To turn off this <span class="built_in">error</span>, run &#x27;gmake GCCPREFIX= ...&#x27;.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo &quot;***&quot; 1&gt;&amp;2; exit 1; fi)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>155行的bootblock</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span> <span class="comment">#得到boot文件夹下所有的.c和.S文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>) <span class="comment">#编译得到.o文件</span></span><br><span class="line"></span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>listfcc</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">listf_cc = <span class="variable">$(<span class="built_in">call</span> listf,$(1)</span>,<span class="variable">$(CTYPE)</span>) <span class="comment">#过滤出对应目录下.c和.S文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>listf</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">listf = <span class="variable">$(<span class="built_in">filter</span> $(<span class="built_in">if</span> $(2)</span>,<span class="variable">$(<span class="built_in">addprefix</span> %.,$(2)</span>),%),\</span><br><span class="line">		  <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">addsuffix</span> <span class="variable">$(SLASH)</span>*,$(1)</span>)))</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>filter</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern&gt;,&lt;text&gt;)</span> <span class="comment">#过滤出符合pattern 的字符串, 可以有多个模式</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">filter</span> %.c %.o,1.c 2.o 3.s)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(OBJ)</span>  <span class="comment">#得到 1.c,2.o</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>wildcard</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span> <span class="comment">#列出当前目录下所有符合模式的文件名</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>cc_compile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cc_compile = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_cc_compile,$(1)</span>,$(2),$(3),$(4)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="练习2-使用qemu软件调试">练习2 使用qemu软件调试</h3>
<p>修改</p>
<p>/kernal</p>
<h3 id="练习3-分析-bootloader-进入保护模式的过程">练习3 分析 bootloader 进入保护模式的过程</h3>
<p>练习3]分析从bootloader进入保护模式的过程。BIOS 将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行 bootloader。请分析bootloader是如何完成从实模式进入保护模式的<br>
提示：需要阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：</p>
<p>1.为何开启A20，以及如何开启A20<br>
2.如何初始化GDT表<br>
3.如何能和进入保护模式</p>
<p>[问题1]为何开启A20门以及如何开启A20<br>
为何开启A20门？</p>
<p>OS boot 的时候为什么要 enable A20？ - 坂本鱼子酱的回答 - 知乎 https://www.zhihu.com/question/29375534/answer/44137152</p>
<p>因为历史原因， A20地址线是被关闭的， 为的是先前兼容。 我们要用的话肯定要打开才行。。</p>
<p>如何开启A20？<br>
打开A20 Gate的具体步骤大致如下：</p>
<p>等待8042 Input buffer为空<br>
发送Write 8042 Output Port （P2） 命令到8042 Input buffer<br>
等待8042 Input buffer为空<br>
将8042 Output Port（P2） 对应字节的第2位置1，然后写入8042 Input buffer<br>
打开A20 Gate的功能是在boot/bootasm.S中实现的，下面结合相关代码来分析：代码分为seta20.1和seta20.2两部分，其中seta20.1是往端口0x64写数据0xd1，告诉CPU我要往8042芯片的P2端口写数据；seta20.2是往端口0x60写数据0xdf，从而将8042芯片的P2端口设置为1. 两段代码都需要先读0x64端口的第2位，确保输入缓冲区为空后再进行后续写操作。</p>
<p>seta20.1:            //等待8042键盘控制器不忙<br>
inb $0x64, %al   //从0x64端口中读入一个字节到al中<br>
testb $0x2, %al  //测试al的第2位<br>
jnz seta20.1     //al的第2位为0，则跳出循环</p>
<pre><code>movb $0xd1, %al  //将0xd1写入al中                         
outb %al, $0x64  //将0xd1写入到0x64端口中                          
</code></pre>
<p>seta20.2:            //等待8042键盘控制器不忙<br>
inb $0x64, %al   //从0x64端口中读入一个字节到al中<br>
testb $0x2, %al  //测试al的第2位<br>
jnz seta20.2     //al的第2位为0，则跳出循环</p>
<pre><code>movb $0xdf, %al  //将0xdf入al中                         
outb %al, $0x60  //将0xdf入到0x64端口中，打开A20                  
</code></pre>
<p>[问题2] 如何初始化GDT表？<br>
初始化GDT表<br>
1、boot/bootasm.S中的lgdt gdtdesc把全局描述符表的大小和起始地址共8个字节加载到全局描述符表寄存器GDTR中。从代码中可以看到全局描述符表的大小为0x17 + 1 = 0x18，也就是24字节。由于全局描述符表每项大小为8字节，因此一共有3项，而第一项是空白项，所以全局描述符表中只有两个有效的段描述符，分别对应代码段和数据段。<br>
gdtdesc:<br>
.word 0x17                                      # sizeof(gdt) - 1<br>
.long gdt                                       # address gdt</p>
<p>2、下面的代码给出了全局描述符表的具体内容。共有3项，每项8字节。第1项是空白项，内容为全0. 后面2项分别是代码段和数据段的描述符，它们的base都设置为0，limit都设置为0xffffff，也就是长度均为4G. 代码段设置了可读和可执行权限，数据段设置了可写权限。<br>
// Bootstrap GDT<br>
.p2align 2                                          # force 4 byte alignment<br>
gdt:<br>
SEG_NULLASM                                     # null seg<br>
SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel<br>
SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<br>
3、SEG_ASM的定义如下<br>
#define SEG_ASM(type,base,lim)                                  <br>
.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);          <br>
.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),             <br>
(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</p>
<p>如何能和进入保护模式</p>
<p>将cr0寄存器的PE位（cr0寄存器的最低位）设置为1，便使能和进入保护模式了。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl %cr0, %eax       &#x2F;&#x2F;加载cro到eax</span><br><span class="line">orl $CR0_PE_ON, %eax  &#x2F;&#x2F;将eax的第0位置为1</span><br><span class="line">movl %eax, %cr0       &#x2F;&#x2F;将cr0的第0位置为1</span><br></pre></td></tr></table></figure>
<h3 id="练习4-分析bootloader加载ELF格式的OS的过程">练习4 分析bootloader加载ELF格式的OS的过程</h3>
<h3 id="练习5-实现函数调用堆栈跟踪函数">练习5 实现函数调用堆栈跟踪函数</h3>
<h3 id="练习6-完善中断初始化和处理">练习6 完善中断初始化和处理</h3>
<p>中断：</p>
<p>CPU一边执行指令, 一边监听着外部事件, 当外部事件发生时, 停下手里的活先去处理外部事件。</p>
<p>CPU设置两根中断输入线来相应两个类型的中断</p>
<ul>
<li>
<p>可屏蔽中断 INTR</p>
<p>CPU可以选择响应. 可以通过IF标志位屏蔽</p>
</li>
<li>
<p>不可屏蔽中断 NIM</p>
<p>CPU必须无条件响应. 如断电</p>
</li>
</ul>
<p>异常：</p>
<p>​	CPU执行指令过程中产生了错误， 也叫软中断，CPU必须无条件响应。</p>
<p>​	常见的有除0，页面故障。</p>
<p>区别：</p>
<p>​	中断是一个异步的过程。 异常是同步的过程， 可复现。</p>
<ul>
<li>中断描述表：</li>
</ul>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359" alt="img" style="zoom: 80%;" />
<ul>
<li>
<p>中断寄存器IDTR</p>
<p><img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100855453" alt="img"></p>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/qwq_circle2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">qwqbot</div><div class="author-info__description">CS-ACM-MUSIC-REANGDING-MOVIE</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pwqbot"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Lab1 系统软件的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="toc-text">实验目的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bootloader%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">bootloader是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-text">实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01-%E7%90%86%E8%A7%A3%E9%80%9A%E8%BF%87make%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">练习1 理解通过make生成执行文件的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#img%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-text">img文件生成过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">编译过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%85%E8%AF%BBmakefile"><span class="toc-text">阅读makefile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02-%E4%BD%BF%E7%94%A8qemu%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95"><span class="toc-text">练习2 使用qemu软件调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A03-%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">练习3 分析 bootloader 进入保护模式的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A04-%E5%88%86%E6%9E%90bootloader%E5%8A%A0%E8%BD%BDELF%E6%A0%BC%E5%BC%8F%E7%9A%84OS%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">练习4 分析bootloader加载ELF格式的OS的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A05-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-text">练习5 实现函数调用堆栈跟踪函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A06-%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-text">练习6 完善中断初始化和处理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #D5F3F4"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By qwqbot</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>