<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统 - Lab1 系统软件的启动过程 | qwqbot</title><meta name="author" content="qwqbot"><meta name="copyright" content="qwqbot"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ucore-Lab1">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统 - Lab1 系统软件的启动过程">
<meta property="og:url" content="http://qwqbot.com/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Lab1/index.html">
<meta property="og:site_name" content="qwqbot">
<meta property="og:description" content="ucore-Lab1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359">
<meta property="article:published_time" content="2021-03-24T00:41:07.340Z">
<meta property="article:modified_time" content="2021-04-21T12:13:04.455Z">
<meta property="article:author" content="qwqbot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359"><link rel="shortcut icon" href="/img/qwq_circle2.jpg"><link rel="canonical" href="http://qwqbot.com/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/Lab1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-21 20:13:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/qwq_circle2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qwqbot</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统 - Lab1 系统软件的启动过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-24T00:41:07.340Z" title="发表于 2021-03-24 08:41:07">2021-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-21T12:13:04.455Z" title="更新于 2021-04-21 20:13:04">2021-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/">CS0804n</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C/">实验</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div STYLE="page-break-after: always;"></div>
<h1>实验目的</h1>
<p>操作系统是一个软件, 也需要通过某种机制加载并运行它. 在这里我们将通过另外一个更加简单的软件-bootloader来完成这些工作. 为此, 我们需要完成一个能够切换到x86的保护模式并显示字符的bootloader, 为启动操作系统ucore做准备. lab1提供了一个非常小的bootloader和ucore OS, 整个bootloader执行代码小于512个字节, 这样才能放到硬盘的主引导扇区中. 通过分析和实现这个bootloader和ucore OS, 我们可以了解到：</p>
<ul>
<li>
<p>计算机原理</p>
<ul>
<li>
<p>CPU的编址与寻址: 基于分段机制的内存管理</p>
</li>
<li>
<p>CPU的中断机制</p>
</li>
<li>
<p>外设：串口/并口/CGA，时钟，硬盘</p>
</li>
</ul>
</li>
<li>
<p>Bootloader软件</p>
<ul>
<li>编译运行bootloader的过程</li>
<li>调试bootloader的方法</li>
<li>PC启动bootloader的过程</li>
<li>ELF执行文件的格式和加载</li>
<li>外设访问：读硬盘, 在CGA上显示字符串 ucore OS软件</li>
</ul>
</li>
<li>
<p>编译运行ucore OS的过程</p>
<ul>
<li>ucore OS的启动过程</li>
<li>调试ucore OS的方法</li>
<li>函数调用关系：在汇编级了解函数调用栈的结构和处理过程</li>
<li>中断管理：与软件相关的中断处理</li>
<li>外设管理：时钟</li>
</ul>
</li>
</ul>
<h2 id="bootloader是什么">bootloader是什么</h2>
<p><strong>[<strong>参考 <a target="_blank" rel="noopener" href="https://www.ionos.com/digitalguide/server/configuration/what-is-a-bootloader">“Bootloader: What you need to know about the system boot manager”</a></strong>]</strong></p>
<blockquote>
<p>Bootloader is a piece of code/program that runs before an operating system starts to run. It loads an operating system when a computer is turned on. It tells the hardware where to look and how to get running when you start things up.</p>
</blockquote>
<p>bootloader是硬件和操作系统之间的中介.</p>
<p>在运行操作系统前, 需要把其装载到RAM中. bootloader就是用来把操作系统从磁盘中装到RAM中, 然后把控制权移交给操作系统的软件.</p>
<p>bootloader通常在放在硬盘的第一个扇区, 该扇区又叫 boot block 或 boot sector.</p>
<p>计算机开始后, 先运行BIOS, 检测硬件等资源, 然后启动bootloader.</p>
<p>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。bootloader完成的工作包括：</p>
<ol>
<li>切换到保护模式，启用分段机制</li>
<li>读磁盘中ELF执行文件格式的ucore操作系统到内存</li>
<li>显示字符串信息</li>
<li>把控制权交给ucore操作系统</li>
</ol>
<div STYLE="page-break-after: always;"></div>
<h1>实验内容</h1>
<p>lab1中包含一个bootloader和一个OS. 这个bootloader可以切换到X86保护模式, 能够读磁盘并加载ELF执行文件格式, 并显示字符. 而这lab1中的OS只是一个可以处理时钟中断和显示字符的幼儿园级别OS.</p>
<div STYLE="page-break-after: always;"></div>
<h2 id="1-理解通过make生成执行文件的过程">1. 理解通过make生成执行文件的过程</h2>
<ul>
<li>
<p>练习要求</p>
<p>在此练习中，需要通过静态分析代码来了解：</p>
<ol>
<li>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命<br>
令参数的含义，以及说明命令导致的结果)</li>
<li>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</li>
</ol>
</li>
<li>
<p>参考资料</p>
<ol>
<li>
<p><strong>makefile中文文档</strong>  ​    https://seisman.github.io/how-to-write-makefile/introduction.html</p>
</li>
<li>
<p><strong>Makefile教程:Makefile文件编写1天入门</strong>	http://c.biancheng.net/makefile/</p>
</li>
<li>
<p><strong>Linux编译工具：gcc入门 - 明澈的文章 - 知乎</strong>	https://zhuanlan.zhihu.com/p/76930507</p>
</li>
</ol>
</li>
</ul>
<h3 id="编译过程">编译过程</h3>
<p>首先进入 <code>~/moocos/ucore_lab/labcodes/lab1</code> 文件夹中. 输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make V=</span><br></pre></td></tr></table></figure>
<p>获得编译过程.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">kern/init/init.c:95:1: warning: ‘lab1_switch_test’ defined but not used [-Wunused-function]</span><br><span class="line"> lab1_switch_test(void) &#123;</span><br><span class="line"> ^</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line"></span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line"></span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">kern/debug/kdebug.c:251:1: warning: ‘read_eip’ defined but not used [-Wunused-function]</span><br><span class="line"> read_eip(void) &#123;</span><br><span class="line"> ^</span><br><span class="line"> </span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line"></span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line"></span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/trap.c</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o</span><br><span class="line">kern/trap/trap.c:14:13: warning: ‘print_ticks’ defined but not used [-Wunused-function]</span><br><span class="line"> static void print_ticks() &#123;</span><br><span class="line">             ^</span><br><span class="line">kern/trap/trap.c:30:26: warning: ‘idt_pd’ defined but not used [-Wunused-variable]</span><br><span class="line"> static struct pseudodesc idt_pd = &#123;</span><br><span class="line">                          ^</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/trapentry.S</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o</span><br><span class="line"></span><br><span class="line">+ cc kern/trap/vectors.S</span><br><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o</span><br><span class="line"></span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line"></span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line"></span><br><span class="line">+ cc libs/string.c</span><br><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line"></span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o</span><br><span class="line"></span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line"></span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"></span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line"></span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">&#x27;obj/bootblock.out&#x27; size: 472 bytes</span><br><span class="line"></span><br><span class="line">build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0187377 s, 273 MB/s</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.5527e-05 s, 6.0 MB/s</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line">138+1 records in</span><br><span class="line">138+1 records out</span><br><span class="line">70775 bytes (71 kB) copied, 0.000266882 s, 265 MB/s</span><br></pre></td></tr></table></figure>
<p>解读一下这些命令.</p>
<p>首先是 <strong>cc</strong> 命令</p>
<ul>
<li>
<p><strong>-fno-builtin</strong></p>
<p>不承认不以 __builtin_ 开头的内置函数. 可以用来避免命名冲突.</p>
</li>
<li>
<p><strong>-Wall</strong></p>
<p>报错</p>
</li>
<li>
<p><strong>-ggdb</strong></p>
<p>基本等于 -g. 生成调试信息</p>
</li>
<li>
<p><strong>-m32</strong></p>
<p>生成32位的程序. 即long, pointer都是32bit的</p>
</li>
<li>
<p><strong>-gstabs</strong></p>
<p>Produce debugging information in stabs format</p>
</li>
<li>
<p><strong>-Idir</strong></p>
<p>指定头文件搜索目录. gcc会先在你指定的目录寻找, 再到默认路径寻找</p>
</li>
<li>
<p><strong>-nostdinc</strong></p>
<p>ignores standard C include directories</p>
</li>
<li>
<p><strong>-c</strong></p>
<p>生成.o的目标文件, 不进行链接过程</p>
</li>
<li>
<p><strong>-o</strong></p>
<p>指定目标文件的名字. 不是生成可执行文件的意思..</p>
</li>
<li>
<p><strong>-fno-stack-protector</strong></p>
<p>关闭栈保护机制.</p>
</li>
</ul>
<p>然后是 <strong>ld</strong> 命令</p>
<ul>
<li>
<p><strong>-m elf_i386</strong></p>
<p>模拟elf_i386链接器</p>
</li>
<li>
<p><strong>-nostdlib</strong></p>
<p>不链接标准库.</p>
</li>
<li>
<p><strong>-N</strong></p>
<p>Set the text and data sections to be readable and writable.</p>
</li>
<li>
<p><strong>-e</strong></p>
<p>设置函数初始执行位置.</p>
</li>
<li>
<p><strong>-T</strong></p>
<p>指明链接脚本,链接脚本是用来指明各个段的位置还有入口之类的链接信息的.</p>
</li>
<li>
<p><strong>-Ttext 0x7c00</strong></p>
<p>指定代码text段在内存中的位置.</p>
</li>
<li>
<p><strong>-o</strong></p>
<p>指明文件名称</p>
</li>
</ul>
<h3 id="项目框架">项目框架</h3>
<p>为了更好的分析项目中的文件依赖关系, 在网上找了一张项目依赖图.(来自 https://xr1s.me/2018/05/15/ucore-lab1-report/)</p>
<p><img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/ucore-lab1-dependency-tree.png" alt="lab1 Makefile 依赖图"></p>
<p><code>ucore.img</code> 的生成过程大致为.</p>
<ol>
<li>
<p>生成 <code>bin/kernel</code></p>
<p>编译链接了 <code>kern/</code> 和 <code>libs/</code> 下的 <code>.c</code> 和  <code>.S</code> 文件</p>
</li>
<li>
<p>生成 <code>bin/block</code></p>
<p>编译链接了 <code>boot/</code> 下的 <code>.c</code> 和 <code>.S</code> 文件得到  <code>obj/bootblock.out</code> , 然后用 <code>sign</code> 将其拷贝到 <code>bin/bootblock</code></p>
</li>
<li>
<p>将  <code>bin/block</code> 拷贝到磁盘的第一个 <code>block</code> , 将 <code>bin/kernel</code> 复制到后面的位置. <code>ucore.img</code> 生成完毕.</p>
</li>
</ol>
<h3 id="阅读makefile">阅读makefile</h3>
<p>了解完项目的整体框架之后, 我们来仔细阅读一下makefile.</p>
<p>首先来到代码178行, 这里定义了 <code>ucore.img</code> 的生成过程.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create ucore.img</span></span><br><span class="line">UCOREIMG	:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span> <span class="comment"># totarget函数的作用是给文件加上 **bin/** 的前缀</span></span><br><span class="line">                                          <span class="comment"># UCOREIMG = bin/ucore.img</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span>       <span class="comment">#两个依赖项</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000 <span class="comment">#先从空白区写入5120000</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc <span class="comment">#把bootblock放到第一个扇区</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc <span class="comment">#把kernel放到第二个之后的扇区</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------命令里的宏定义-----------------</span></span><br><span class="line">V := @  <span class="comment">#makefile在命令前加@表示只显示命令结果不显示其本身</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>totarget</code> 函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">totarget = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BINDIR)</span><span class="variable">$(SLASH)</span>,$(1)</span>) <span class="comment"># 封装了内置的addprefix函数</span></span><br><span class="line"><span class="variable">$(addperfix &lt;prefix&gt;,&lt;names&gt;)</span> <span class="comment"># 把prefix加到names的每个单词前面, 返回值为添加完的单词序列</span></span><br><span class="line">BINDIR  := bin                <span class="comment"># 宏定义</span></span><br><span class="line">SLASH   := /				  <span class="comment"># 宏定义</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dd</code>命令</p>
<p>linux 用来读取转换并输出数据的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if = 输入文件名 of = 输出文件名 bs = 输入/输出的块的大小 seek = blcoks count = blocks conv = notrunc</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>bs=bytes</code></p>
<p>同时设置读入/输出的块大小为bytes个字节.默认512</p>
</li>
<li>
<p><code>seek = blocks</code><br>
输出文件开始跳过blocks块再复制</p>
</li>
<li>
<p><code>count = blocks</code></p>
<p>拷贝blocks个块</p>
</li>
<li>
<p><code>conv = notrunc</code></p>
<p>不截断输出文件</p>
</li>
</ul>
</li>
</ul>
<p>上面的命令对应着编译时看到的.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000 </span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB) copied, 0.0187377 s, 273 MB/s</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc #把bootblock放到第一个扇区</span><br><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 8.5527e-05 s, 6.0 MB/s</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc </span><br><span class="line">138+1 records in</span><br><span class="line">138+1 records out</span><br><span class="line">70775 bytes (71 kB) copied, 0.000266882 s, 265 MB/s</span><br></pre></td></tr></table></figure>
<p>接下来分析 <code>ucore.img</code> 的两个依赖项 <code>kernel</code> 和 <code>bootblock</code>.</p>
<h4 id="kernel">kernel</h4>
<p><code>kernel</code> 的定义在第140行</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create kernel target</span></span><br><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span>  <span class="comment"># kernel = bin/kernel</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld        <span class="comment"># 依赖于 kernel.ld 链接器</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span>  </span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span> </span><br></pre></td></tr></table></figure>
<p>暂时不看它的依赖项, 先来分析一下它做了啥.</p>
<ul>
<li>
<p>line 8</p>
<p>链接命令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span>  </span><br></pre></td></tr></table></figure>
<p>链接命令. 使用的链接器为 <code>tools/kernel.ld</code>. 生成了目标文件 <code>$@</code>， 使用的文件是<code>$(KOBJS)</code> , 在后面会分析.</p>
<p><code>$(V)</code> 就是 <code>$@</code>, 不输出命令本身只输出命令结果.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LD := <span class="variable">$(GCCPREFIX)</span>ld </span><br></pre></td></tr></table></figure>
<p><code>$(GCCPREFIX)</code> 搜索 <code>i386-elf-objdump</code> 命令, 如果存在则为<code>i386-elf-</code>, 否则为空串.</p>
<p><code>objdump</code> 是用查看目标文件或者可执行的目标文件的构成的gcc工具.</p>
<p><code>objdump -i</code> 显示所有可用的架构和可用的目标格式.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try to infer the correct GCCPREFX</span></span><br><span class="line"><span class="keyword">ifndef</span> GCCPREFIX</span><br><span class="line">GCCPREFIX := <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> i386-elf-objdump -i 2&gt;&amp;1 | grep &#x27;^elf32-i386$$&#x27; &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">then echo &#x27;i386-elf-&#x27;; \</span></span><br><span class="line"><span class="variable">elif objdump -i 2&gt;&amp;1 | grep &#x27;elf32-i386&#x27; &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">then echo &#x27;&#x27;; \</span></span><br><span class="line"><span class="variable">else echo &quot;***&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;*** Error: Couldn&#x27;t find an i386-elf version of GCC/binutils.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;*** Is the directory with i386-elf-gcc in your PATH?&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;*** If your i386-elf toolchain is installed with a command&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;*** prefix other than &#x27;i386-elf-&#x27;, set your GCCPREFIX&quot; 1&gt;&amp;2; \   </span></span><br><span class="line"><span class="variable">echo &quot;*** environment variable to that prefix <span class="built_in">and</span> run &#x27;make&#x27; again.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;*** To turn off this <span class="built_in">error</span>, run &#x27;gmake GCCPREFIX= ...&#x27;.&quot; 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">echo &quot;***&quot; 1&gt;&amp;2; exit 1; fi)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p><code>LDFLAGS</code> 是一些链接选项.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出链接器的版本信息, 找出其中含有 elf_i386的行, 显示第一行. </span></span><br><span class="line"><span class="comment"># 2&gt;/dev/null 表示把标准错误信息重定向到/dev/null中, 相当于扔掉.</span></span><br><span class="line"><span class="comment"># 参考 https://askubuntu.com/questions/350208/what-does-2-dev-null-mean?newreg=2f170d448537461ba142f1dd3478bc27</span></span><br><span class="line">LDFLAGS := -m <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(LD)</span> -V | grep elf_i386 2&gt;/dev/null | head -n 1)</span></span><br><span class="line">LDFLAGS	+= -nostdlib <span class="comment"># 不使用标准库</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>line 9-10</p>
<p>9,10两行使用了objdump进行反汇编. 主要是一些字符串操作.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span> <span class="comment">#反汇编目标文件, 并输入到 obj/kernel.asm中</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span> <span class="comment">#把符号表存到 obj/kernel.sym中</span></span><br></pre></td></tr></table></figure>
<p>把 <code>objdump</code> 分析出的信息输入到指定文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJDUMP := <span class="variable">$(GCCPREFIX)</span>objdump</span><br><span class="line">objdump -S <span class="comment"># 尽可能反汇编出源代码</span></span><br><span class="line">objdump -t <span class="comment"># 显示文件的符号表入口</span></span><br></pre></td></tr></table></figure>
<p><code>SED</code> 是一个简单的宏替换.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SED := sed  <span class="comment">#linux命令. 使用正则表达式来处理文本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>asmfile</code></p>
<p>给字符串加前后缀.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">asmfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,asm) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里call 了两个函数 cgtype和 toobj. 先来研究一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#toobj函数作用是给文件名的前缀加上 obj/ 后缀改成.o </span></span><br><span class="line">toobj = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJDIR)</span><span class="variable">$(SLASH)</span>$(<span class="built_in">if</span> $(2)</span>,$(2)<span class="variable">$(SLASH)</span>),<span class="variable">$(<span class="built_in">addsuffix</span> .o,$(<span class="built_in">basename</span> $(1)</span>)))  </span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">basename</span> Names)</span> <span class="comment"># 内置函数, 取出文件名的前缀部分, 即点号之前</span></span><br><span class="line">OBJDIR	:= obj </span><br><span class="line">SLASH	:= /</span><br><span class="line"></span><br><span class="line"><span class="comment">#cgtype的作用是替换文件中的模式串.</span></span><br><span class="line"><span class="comment">#第一个参数是要被替换的文件. 第二个参数是源模式, 第三个参数是目标模式</span></span><br><span class="line">cgtype = <span class="variable">$(<span class="built_in">patsubst</span> %.$(2)</span>,%.$(3),$(1))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#替换文件中的文本的. 使用%可以匹配任意字符.</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> PATTERN,REPLACEMENT,TEXT)</span> </span><br></pre></td></tr></table></figure>
<p>所以<code>asmfile</code>的作用先把输入文件名 <code>x</code>转换成 <code>obj/x.asm</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> asmfile, kernel)</span> <span class="comment">#得到了 obj/kernel.asm 里面存着kernel的反汇编出来的代码</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>symfile</code></p>
<p>和<code>amsfile</code> 类似的函数.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">symfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,sym) <span class="comment"># 把输入文件名 x转换成 obj/x.sym</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span> <span class="comment">#得到了 obj/kernel.sym 里面存着kernel的符号表</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么是SYM文件?</p>
<p>软件开发应用程序使用的开发人员文件; 保存实际程序二进制可执行文件的非必需信息, 但包含可在调试时用于收集程序信息的符号; 可以包括函数和变量名以及其他有用的调试信息.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>line 6</p>
<p>这行定义了 <code>kernel</code> 依赖于 <code>KOBJS</code>.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取kern和libs下的所有文件. KOBJS = obj/kern/.. 和 obj/libs/...</span></span><br><span class="line">KOBJS	= <span class="variable">$(<span class="built_in">call</span> read_packet,kernel libs)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_packet = <span class="variable">$(<span class="built_in">foreach</span> p,$(<span class="built_in">call</span> packetname,$(1)</span>),$(<span class="variable">$(p)</span>))  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span> <span class="comment">#把list中的每个变量取出来, 然后把它看成var, 最后执行text, </span></span><br><span class="line"></span><br><span class="line">packetname = <span class="variable">$(<span class="built_in">if</span> $(1)</span>,<span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OBJPREFIX)</span>,$(1)</span>),<span class="variable">$(OBJPREFIX)</span>) <span class="comment"># 给名字加一个__objs_ 的前缀</span></span><br><span class="line">OBJPREFIX	:= __objs_</span><br></pre></td></tr></table></figure>
<p><code>obj/libs</code> 和 <code>obj/kernel</code> 的文件又是怎么来的呢. 主要用到了<code>add_files_cc</code> 函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用了 add_files_cc 函数. </span></span><br><span class="line"><span class="comment"># 搜索 libs 下所有的.c和.S文件 并生成 .o文件, 放在 libs文件夹下</span></span><br><span class="line"><span class="comment"># 搜索 kern 下所有的.c和.S文件 并生成 .o文件, 放在 kernel文件夹下</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(LIBDIR)</span>)</span>,libs,)</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(KSRCDIR)</span>)</span>,kernel,<span class="variable">$(KCFLAGS)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先看一些简单的宏</span></span><br><span class="line"><span class="comment"># 这是两个源文件夹</span></span><br><span class="line">LIBDIR	+= libs</span><br><span class="line">KSRCDIR		+= kern/init \</span><br><span class="line">			   kern/libs \</span><br><span class="line">			   kern/debug \</span><br><span class="line">			   kern/driver \</span><br><span class="line">			   kern/trap \</span><br><span class="line">			   kern/mm \</span><br><span class="line">			   kern/sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel 的编译命令</span></span><br><span class="line">KCFLAGS		+= <span class="variable">$(<span class="built_in">addprefix</span> -I,<span class="variable">$(KINCLUDE)</span>)</span></span><br><span class="line">KINCLUDE	+= kern/debug/ \</span><br><span class="line">			   kern/driver/ \</span><br><span class="line">			   kern/trap/ \</span><br><span class="line">			   kern/mm/ \</span><br><span class="line">			   kern/libs/ \</span><br><span class="line">			   kern/sync/</span><br></pre></td></tr></table></figure>
<p><code>listf_cc</code> 列出文件夹中指定格式的文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出 传入的第一个参数下的所有 .c和.S文件</span></span><br><span class="line">listf_cc = <span class="variable">$(<span class="built_in">call</span> listf,$(1)</span>,<span class="variable">$(CTYPE)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#list all files in some directories: (#directories, #types)</span></span><br><span class="line">listf = <span class="variable">$(<span class="built_in">filter</span> $(<span class="built_in">if</span> $(2)</span>,<span class="variable">$(<span class="built_in">addprefix</span> %.,$(2)</span>),%),\</span><br><span class="line">  		  <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">addsuffix</span> <span class="variable">$(SLASH)</span>*,$(1)</span>))</span><br><span class="line">  		  </span><br><span class="line">CTYPE	:= c S</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>filter</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern&gt;,&lt;text&gt;)</span> <span class="comment">#过滤出符合pattern 的字符串, 可以有多个模式</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">filter</span> %.c %.o,1.c 2.o 3.s)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>wildcard</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span> <span class="comment">#列出当前目录下所有符合模式的文件名</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>给 <code>add_files_cc</code> 传入了待编译文件, 文件夹和编译选项参数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译文件到指定目录下.</span></span><br><span class="line"><span class="comment"># $(1) = libs/...       $(2) = libs kernel  $(3) = empty $(4) = empty</span></span><br><span class="line"><span class="comment"># $(1) = kernel/...     $(2) = kernel       $(3) = KCFLAGS </span></span><br><span class="line">add_files_cc = <span class="variable">$(<span class="built_in">call</span> add_files,$(1)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> $(3),$(2),$(4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># add files to packet: (#files, cc[, flags, packet, dir])</span></span><br><span class="line"><span class="comment"># 把 files 成 .o 文件, 放到   obj/packet目录下</span></span><br><span class="line"><span class="comment"># (libs/..., CC, CFLAGS, libs, empty)</span></span><br><span class="line"><span class="comment"># (kernel/..., CC, CFLAGS KCFLGS, kernel, empty)</span></span><br><span class="line">add_files = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_add_files_to_packet,$(1)</span>,$(2),$(3),$(4),$(5)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># add files to packet: (#files, cc[, flags, packet, dir])</span></span><br><span class="line"><span class="keyword">define</span> do_add_files_to_packet</span><br><span class="line">__temp_packet__ := <span class="variable">$(<span class="built_in">call</span> packetname,$(4)</span>)</span><br><span class="line"><span class="keyword">ifeq</span> ($<span class="variable">$(<span class="built_in">origin</span> $<span class="variable">$(__temp_packet__)</span>)</span>,undefined)</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> :=</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">__temp_objs__ := <span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(5))</span><br><span class="line">$<span class="variable">$(<span class="built_in">foreach</span> f,$(1)</span>,$<span class="variable">$(<span class="built_in">eval</span> $$(<span class="built_in">call</span> cc_template,$<span class="variable">$(f)</span>,$(2)</span>,$(3),$(5))))</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> += $<span class="variable">$(__temp_objs__)</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])</span></span><br><span class="line"><span class="comment"># 编译模板</span></span><br><span class="line"><span class="keyword">define</span> cc_template</span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -MM $<span class="variable">$&lt;</span> -MT <span class="string">&quot;$$(patsubst %.d,%.o,$<span class="variable">$@</span>) $<span class="variable">$@</span>&quot;</span>&gt; $<span class="variable">$@</span></span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@echo + cc $<span class="variable">$&lt;</span></span><br><span class="line">	<span class="variable">$(V)</span>$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -c $<span class="variable">$&lt;</span> -o $<span class="variable">$@</span></span><br><span class="line">ALLOBJS += $<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4))</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>line 12</p>
<p>调用了<code>create_target</code> 函数, 该函数有五个参数, 这里只传入了一个参数 <code>kernel</code>.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span> </span><br></pre></td></tr></table></figure>
<p><code>create_target</code> 函数在<code>bin/</code> 文件夹下建立目标文件, 并为其自动添加 <code>makefile</code> 的编译语句.</p>
<p>这里只是给<code>bin/kernel</code> 添加了一个依赖关系 <code>bin/</code>.  好像没什么用…</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add packets and objs to target (target, #packes, #objs, cc, [, flags])</span></span><br><span class="line">create_target = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_create_target,$(1)</span>,$(2),$(3),$(4),$(5))) <span class="comment">#不懂在干啥</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># add packets and objs to target (target, #packes, #objs[, cc, flags])</span></span><br><span class="line"><span class="keyword">define</span> do_create_target</span><br><span class="line">__temp_target__ = <span class="variable">$(<span class="built_in">call</span> totarget,$(1)</span>)     <span class="comment"># bin/$(1)</span></span><br><span class="line">__temp_objs__ = $<span class="variable">$(<span class="built_in">foreach</span> p,$(<span class="built_in">call</span> packetname,$(2)</span>),$$($<span class="variable">$(p)</span>)) $(3)</span><br><span class="line">TARGETS += $<span class="variable">$(__temp_target__)</span></span><br><span class="line"><span class="keyword">ifneq</span> ($(4),)     <span class="comment"># 如果传入了cc,则进行编译</span></span><br><span class="line"><span class="section">$$(__temp_target__): $<span class="variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="variable">$@</span>) </span></span><br><span class="line">	<span class="variable">$(V)</span>$(4) $(5) $<span class="variable">$^</span> -o $<span class="variable">$@</span></span><br><span class="line"><span class="keyword">else</span>              <span class="comment"># 否则只添加一个依赖关系</span></span><br><span class="line"><span class="section">$$(__temp_target__): $<span class="variable">$(__temp_objs__)</span> | $$$$(dir $$$<span class="variable">$@</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir函数是用来取目录名的</span></span><br><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span> -&gt; src/ ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># $$(__temp_objs__) | $$$$(dir $$$$@)  中的 竖线 | 表示后面的文件是命令前提目标</span></span><br><span class="line"><span class="comment"># 表示只有在目标文件不存在时这个规则才有效. </span></span><br><span class="line"><span class="comment"># 若目标文件已经存在, 则命令前提的目标的修改不会重新引起目标文件的修改.</span></span><br><span class="line"><span class="comment"># 参考 https://www.codeleading.com/article/55515256728/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="bootblock">bootblock</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span> <span class="comment">#得到boot文件夹下所有的.c和.S文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>) <span class="comment">#编译得到.o文件</span></span><br><span class="line"></span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span> <span class="comment"># bin/bootblock</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br></pre></td></tr></table></figure>
<p>先看一下实现, 再看一下bootblock的依赖</p>
<ul>
<li>
<p>line 9</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br></pre></td></tr></table></figure>
<p>也是一个链接命令. 注意两个参数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-e start <span class="comment"># start定义在bootasm.S 中, 将其设置为bootblock的入口.</span></span><br><span class="line">-Ttext 0x7c00 <span class="comment"># 表示代码段的起始位置为0x7c00</span></span><br><span class="line"><span class="variable">$^</span> <span class="comment">#表示所有的依赖项 这里是 obj/boot/bootasm.o  obj/boot/bootmain.o</span></span><br><span class="line"><span class="comment"># 目标文件  obj/bootbolock.o</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>line10,11</p>
<p>这两行和 <code>kernel</code> 中的两行差不多, 反汇编<code>obj/bootblock.o</code> 这个文件.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span> <span class="comment"># 反汇编 obj/bootblcok.o 输入到 obj/bootblock.asm</span></span><br><span class="line">@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span><span class="comment">#把 obj/bootblock.o 拷贝到 obj/bootblock.out</span></span><br></pre></td></tr></table></figure>
<p>有两个没见过的命令 <code>outfile</code> 和 <code>BOJCOPY</code>.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">outfile = <span class="variable">$(<span class="built_in">call</span> cgtype,$(<span class="built_in">call</span> toobj,$(1)</span>),o,out)  <span class="comment">#　x-&gt; obj/x.out</span></span><br><span class="line">OBJCOPY := <span class="variable">$(GCCPREFIX)</span>objcopy <span class="comment">#拷贝文件的函数.</span></span><br><span class="line"><span class="comment"># -S , --strip-all : 不从源文件拷贝符号信息和重(zhong)定位信息。</span></span><br><span class="line"><span class="comment"># -O bfdname , --output-target=bfdname : 指定输出文件的 bfdname</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>line 12</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span> <span class="comment"># 使用bin/sign把 obj/bootblock.out 拷贝到 bin/bootblock中</span></span><br></pre></td></tr></table></figure>
<p>看一下 <code>bin/sign</code> 的形成过程. 和之前的 <code>kernel</code> 下的文件编译差不多</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create &#x27;sign&#x27; tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span> </span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br><span class="line"></span><br><span class="line">add_files_host = <span class="variable">$(<span class="built_in">call</span> add_files,$(1)</span>,<span class="variable">$(HOSTCC)</span>,<span class="variable">$(HOSTCFLAGS)</span>,$(2),$(3))</span><br><span class="line">HOSTCC		:= gcc           <span class="comment"># 用 gcc 编译</span></span><br><span class="line">HOSTCFLAGS	:= -g -Wall -O2  <span class="comment"># 编译参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add files to packet: (#files, cc[, flags, packet, dir])</span></span><br><span class="line">add_files = <span class="variable">$(<span class="built_in">eval</span> $(<span class="built_in">call</span> do_add_files_to_packet,$(1)</span>,$(2),$(3),$(4),$(5)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> do_add_files_to_packet</span><br><span class="line">__temp_packet__ := <span class="variable">$(<span class="built_in">call</span> packetname,$(4)</span>)</span><br><span class="line"><span class="keyword">ifeq</span> ($<span class="variable">$(<span class="built_in">origin</span> $<span class="variable">$(__temp_packet__)</span>)</span>,undefined)</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> :=</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">__temp_objs__ := <span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(5))</span><br><span class="line">$<span class="variable">$(<span class="built_in">foreach</span> f,$(1)</span>,$<span class="variable">$(<span class="built_in">eval</span> $$(<span class="built_in">call</span> cc_template,$<span class="variable">$(f)</span>,$(2)</span>,$(3),$(5))))</span><br><span class="line">$<span class="variable">$(__temp_packet__)</span> += $<span class="variable">$(__temp_objs__)</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])</span></span><br><span class="line"><span class="comment"># 编译模板</span></span><br><span class="line"><span class="keyword">define</span> cc_template</span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> todep,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -MM $<span class="variable">$&lt;</span> -MT <span class="string">&quot;$$(patsubst %.d,%.o,$<span class="variable">$@</span>) $<span class="variable">$@</span>&quot;</span>&gt; $<span class="variable">$@</span></span><br><span class="line">$<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4)): $(1) | $$$<span class="variable">$(<span class="built_in">dir</span> $$$<span class="variable">$@</span>)</span></span><br><span class="line">	@echo + cc $<span class="variable">$&lt;</span></span><br><span class="line">	<span class="variable">$(V)</span>$(2) -I$<span class="variable">$(<span class="built_in">dir</span> $(1)</span>) $(3) -c $<span class="variable">$&lt;</span> -o $<span class="variable">$@</span></span><br><span class="line">ALLOBJS += $<span class="variable">$(<span class="built_in">call</span> toobj,$(1)</span>,$(4))</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个<code>gcc</code> 的编译模板, 然后<code>add_files</code> 调用了 <code>do_add_files_to_packet</code>, 后者调用了这个模板.</p>
<p>结果是把 <code>tools/sign.c</code> 编译成 <code>sign</code></p>
<p>阅读一下 <code>tools/sign.c</code> , 它把输入文件拷贝到输出文件, 并且检查大小是否小于等于510个字节, 并把511和512个字节设置为特殊字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检验</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;  <span class="comment">// 猜测应该是0表示正确打开</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;    <span class="comment">// 输入文件大小要小于510个字节</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>]; </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp);  <span class="comment">// 从输入文件中写入缓冲区. 第二个参数表示每个元素有几个字节.</span></span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>; <span class="comment">//这是最后两个字节为 0x55 0xAA</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);  </span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);   <span class="comment">//写到输出文件. </span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>line2,3,7</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span> <span class="comment">#得到boot文件夹下所有的.c和.S文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>) <span class="comment">#.c和.S编译得到.o文件</span></span><br><span class="line"></span><br><span class="line">listf_cc = <span class="variable">$(<span class="built_in">call</span> listf,$(1)</span>,<span class="variable">$(CTYPE)</span>) <span class="comment">#过滤出对应目录下.c和.S文件</span></span><br><span class="line">listf = <span class="variable">$(<span class="built_in">filter</span> $(<span class="built_in">if</span> $(2)</span>,<span class="variable">$(<span class="built_in">addprefix</span> %.,$(2)</span>),%),\</span><br><span class="line">		  <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">addsuffix</span> <span class="variable">$(SLASH)</span>*,$(1)</span>))) </span><br><span class="line">CTYPE	:= c S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="comment">#依赖项是 obj/boot/... 和 bin/sign</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>filter</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern&gt;,&lt;text&gt;)</span> <span class="comment">#过滤出符合pattern 的字符串, 可以有多个模式</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">filter</span> %.c %.o,1.c 2.o 3.s)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(OBJ)</span>  <span class="comment">#得到 1.c,2.o</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>wildcard</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span> <span class="comment">#列出当前目录下所有符合模式的文件名</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-问题回答">1.3 问题回答</h4>
<ol>
<li>
<p>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命<br>
令参数的含义，以及说明命令导致的结果)</p>
<p>上面已经回答了</p>
</li>
<li>
<p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
<p>大小为 512字节, 最后两个字节为 0x55 0xAA</p>
</li>
</ol>
<div STYLE="page-break-after: always;"></div>
<h2 id="2-使用qemu软件调试">2. 使用qemu软件调试</h2>
<ul>
<li>
<p>练习要求</p>
<p>为了熟悉使用qemu和gdb进行的调试工作, 我们进行如下的小练习:</p>
<ol>
<li>从CPU加电后执行的第一条指令开始,单步跟踪BIOS的执行.</li>
<li>在初始化位置0x7c00设置实地址断点, 测试断点正常.</li>
<li>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较.</li>
<li>自己找一个bootloader或内核中的代码位置,设置断点并进行测试.</li>
</ol>
</li>
<li>
<p>参考资料</p>
<ol>
<li><strong>QEMU-wiki</strong> https://zh.wikipedia.org/wiki/QEMU</li>
</ol>
</li>
</ul>
<p>实验之前先了解一下QEMU是啥.</p>
<blockquote>
<p>QEMU是一个托管的虚拟机镜像，它通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS，可以通过与KVM（kernel-based virtual machine开源加速器）一起使用进而接近本地速度运行虚拟机（接近真实电脑的速度）。</p>
<p>QEMU有多种模式[1]</p>
<p>User mode：又称作“用户模式”，在这种模块下，QEMU运行针对不同指令编译的单个Linux或Darwin/macOS程序。系统调用与32/64位接口适应。在这种模式下，我们可以实现交叉编译（cross-compilation）与交叉侦错（cross- debugging）。<br>
System mode：“系统模式”，在这种模式下，QEMU模拟一个完整的计算机系统，包括外围设备。它可以用于在一台计算机上提供多台虚拟计算机的虚拟主机。 QEMU可以实现许多客户机OS的引导，比如x86，MIPS，32-bit ARMv7，PowerPC等等。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/QEMU">wiki</a></p>
</blockquote>
<p>它是一个虚拟机,用软件来模拟硬件. qemu的特点是可以模拟不同的硬件平台架构.</p>
<blockquote>
<p>Qemu可以模拟CPU - 通过二进制翻译将一个指令集翻译成另一种指令集；可以模拟MMU - 管理用户os，或者用户进程（取决于qemu是工作在系统态还是用户态）；可以模拟IO - 抽象实际的物理设备。</p>
</blockquote>
<p>​</p>
<h3 id="2-1-QEMU调试">2.1 QEMU调试</h3>
<p>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure>
<p>之后, 进入gdb调试.</p>
<p>找到makefile中的定义</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">debug-nox: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(QEMU)</span> -S -s -serial mon:stdio -hda <span class="variable">$&lt;</span> -nographic &amp;</span><br><span class="line">	<span class="variable">$(V)</span>sleep 2</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">&quot;gdb -q -x tools/gdbinit&quot;</span> </span><br></pre></td></tr></table></figure>
<p>解释一下gdb的两个参数.</p>
<ul>
<li>
<p><strong>-p</strong></p>
<p>不显示没用的信息</p>
</li>
<li>
<p><strong>-x tools/gdbinit</strong></p>
<p>表示执行 tools/gdbinit 中的gdb命令</p>
</li>
</ul>
<p>了解一下 gdbinit 的内容</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">file bin/kernel 	<span class="comment"># 打开bin/kernel文件</span></span><br><span class="line">target remote :1234 <span class="comment"># 与QEMU建立联系</span></span><br><span class="line">break kern_init 	<span class="comment"># 设置断点</span></span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<h3 id="2-2-从CPU加电后执行的第一条指令开始-单步跟踪BIOS的执行">2.2 从CPU加电后执行的第一条指令开始,单步跟踪BIOS的执行.</h3>
<p>修改 gdbinit</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure>
<p>在gdb中查看汇编代码和寄存器</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">layout asm</span><br><span class="line">layout regs</span><br></pre></td></tr></table></figure>
<p>代码停在了第一条指令, 此时 cs 的值为 0xf000, eip 的值为 0xfff0.</p>
<p>但是这时候汇编代码是错误的</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406191540592.png" alt="image-20210406191540592" style="zoom:50%;" />
<p>输入</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x/2i 0xffff0</span><br></pre></td></tr></table></figure>
<p>这时候确实显示了正确的汇编代码.</p>
<p><img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406191831529.png" alt="image-20210406191831529"></p>
<p>而且看到gdb窗口中的pc值好像也不对?</p>
<p>单步调试</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">si</span><br></pre></td></tr></table></figure>
<p>程序跳转到 0xfe05b</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406192017488.png" alt="image-20210406192017488" style="zoom:50%;" />
<p>上网搜索了一下, 说<strong>gdb无法处理实模式的分段</strong>. 所以他在实模式下只会显示 eip 的内存值.</p>
<h3 id="2-3-在初始化位置0x7c00设置实地址断点-测试断点正常">2.3 在初始化位置0x7c00设置实地址断点, 测试断点正常.</h3>
<p>修改 gdbinit</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">set arch i8086 	<span class="comment"># 设置为 i8086</span></span><br><span class="line">target remote :1234 <span class="comment"># 与QEMU建立联系</span></span><br><span class="line">break *0x7c00 	<span class="comment"># 设置断点</span></span><br></pre></td></tr></table></figure>
<p>成功设置断点</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406193100973.png" alt="image-20210406193100973" style="zoom:50%;" />
<p>可以看到这时候的内存中的汇编代码显示正确了, 这是因为cs的值为0, 所以地址就是eip指针.</p>
<h3 id="2-4-从0x7c00开始跟踪代码运行-将单步跟踪反汇编得到的代码与bootasm-S和-bootblock-asm进行比较">2.4 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较.</h3>
<p>在窗口中查看汇编代码</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406193828089.png" alt="image-20210406193828089" style="zoom:50%;" />
<p>发现与bootams.s 的基本一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br></pre></td></tr></table></figure>
<h3 id="2-5-自己找一个bootloader或内核中的代码位置-设置断点并进行测试">2.5 自己找一个bootloader或内核中的代码位置,设置断点并进行测试.</h3>
<p>进入保护模式之后要把架构设成80386的32位模式</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">set arch i386</span><br></pre></td></tr></table></figure>
<p>到达bootmain.c的接口</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406195907455.png" alt="image-20210406195907455" style="zoom:50%;" />
<div STYLE="page-break-after: always;"></div>
<h2 id="3-分析-bootloader-进入保护模式的过程">3. 分析 bootloader 进入保护模式的过程</h2>
<ul>
<li>
<p>参考</p>
<ol>
<li>
<p><strong>阮一峰 为什么主引导记录的内存地址是0x7C00？</strong> http://www.ruanyifeng.com/blog/2015/09/0x7c00.html</p>
</li>
<li>
<p><strong>ucore实验指导书 Lab1 附录A“关于A20 Gate”</strong> https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_appendix_a20.html</p>
</li>
<li>
<p><strong>“关于 A20 Gate”</strong> http://hengch.blog.163.com/blog/static/107800672009013104623747/</p>
</li>
</ol>
</li>
</ul>
<p>提示：需要阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：</p>
<ol>
<li>为何开启A20, 以及如何开启A20</li>
<li>如何初始化GDT表</li>
<li>如何使能和进入保护模式</li>
</ol>
<h3 id="3-1为何开启A20-以及如何开启A20">3.1为何开启A20, 以及如何开启A20</h3>
<ul>
<li>
<p>8086</p>
<p>CPU地址线 20 位. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>00000</mn><mo>−</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">00000 - FFFFF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>. 而 8086的数据处理位宽只有16位. 所以采用 <strong>段地址加偏移地址</strong> 的地址转换规则.</p>
<p>寻址结构是 segment: offset. 把段地址左移四位, 加上偏移地址. 这样能到达的最大的寻址空间为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mn>0</mn><mo>+</mo><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mo>=</mo><mn>10</mn><mi>F</mi><mi>F</mi><mi>E</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">FFFF0 + FFFF = 10FFEF
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span></p>
<p>显然比最大的内存地址 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">FFFFF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 大一点.</p>
<p>于是当寻址超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">FFFFF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> , 即 1MB 的内存的时候, CPU会发生回卷.</p>
</li>
<li>
<p>80286</p>
<p>80286的地址线为 24位 16MB 的寻址范围. 所以不必再有回卷操作. 但是为了 <strong>向下兼容</strong>, IBM 增加了一个 A20 Gate 来模拟原来的环绕逻辑.</p>
<p>在实模式下只要将A20 Gate 关闭, 就可以在硬件上模拟出8086的回卷效果, 实现了向下兼容.</p>
<p>在实模式下, 想要访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100000</mn><mo>−</mo><mn>10</mn><mi>F</mi><mi>F</mi><mi>E</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">100000 - 10FFEF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 这段内存, 必须打开 A20 Gate.</p>
<p>同样的, 在保护模式下, 如果不打开 A20 Gate 那么相当于地址中第20位一直是0, 访问内存的时候只能访问 0-1M, 2-3M 这样的奇数M的内存.</p>
</li>
<li>
<p>开启A20</p>
<p>开启A20Gate需要通过向键盘控制器8042发送一个命令来完成.</p>
<p>键盘控制器8042将会将它的的某个输出引脚的输出置高电平,作为 A20 地址线控制的输入.</p>
<blockquote>
<p>早期的PC机，控制键盘有一个单独的单片机8042，现如今这个芯片已经给集成到了其它大片子中，但其功能和使用方法还是一样，当PC机刚刚出现A20 Gate的时候，估计实在找不到控制它的地方了，同时为这点小事也不值得增加芯片，于是工程师使用这个8042键盘控制器来控制A20 Gate，但A20 Gate真的和键盘一点关系也没有  ——-“关于A20 Gate”</p>
</blockquote>
<p>理论上讲, 我们只要操作8042芯片的输出端口(64h)的bit 1,就可以控制A20 Gate,但实际上,当你准备向<br>
8042的输入缓冲区里写数据时,可能里面还有其它数据没有处理,所以，我们要首先禁止键盘操作，同时等待数据缓<br>
冲区中没有数据以后，才能真正地去操作8042打开或者关闭A20 Gate。打开A20 Gate的具体步骤大致如下（参考<br>
bootasm.S）：</p>
<ol>
<li>等待8042 Input buffer为空；</li>
<li>发送Write 8042 Output Port （P2）命令到8042 Input buffer；</li>
<li>等待8042 Input buffer为空；</li>
<li>将8042 Output Port（P2）得到字节的第2位置1，然后写入8042 Input buffer；</li>
</ol>
</li>
<li>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # 关中断, 禁止键盘操作</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line"># Enable A20:</span><br><span class="line">#  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">#  address line 20 is tied low, so that addresses higher than</span><br><span class="line">#  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                  # 读取8024的status register   Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al                 # 等待bit1为0, 即输入缓存是空的</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 表示要写入8042的output port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-如何初始化GDT表">3.2 如何初始化GDT表</h3>
<p>接下来的一行代码初始化了GDT表.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lgdt gdtdesc</span><br></pre></td></tr></table></figure>
<p>找到 gdtdesc 的定义可以得到gdt表的大小和起始地址. 这里gdt表的大小为 24bytes, 每个段描述符占8 个bytes. 所以三个描述符分别是一个空白段, 一个代码段, 一个数据段.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # 第一个空白段</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # 代码段 code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # 数据段 data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word 0x17                                      # gdt表的大小为 24bytes.  sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # 起始位置. address gdt</span><br></pre></td></tr></table></figure>
<p>继续寻找一下段描述符的具体定义, 在 asm.h 文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Normal segment *&#x2F;</span><br><span class="line">#define SEG_NULLASM                                             \</span><br><span class="line">    .word 0, 0;                                                 \</span><br><span class="line">    .byte 0, 0, 0, 0</span><br><span class="line"></span><br><span class="line">#define SEG_ASM(type,base,lim)                                  \</span><br><span class="line">    .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);          \  &#x2F;&#x2F;前4byte</span><br><span class="line">    .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),             \  &#x2F;&#x2F;后4byte</span><br><span class="line">        (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* Application segment type bits *&#x2F;</span><br><span class="line">#define STA_X       0x8     &#x2F;&#x2F; Executable segment</span><br><span class="line">#define STA_E       0x4     &#x2F;&#x2F; Expand down (non-executable segments)</span><br><span class="line">#define STA_C       0x4     &#x2F;&#x2F; Conforming code segment (executable only)</span><br><span class="line">#define STA_W       0x2     &#x2F;&#x2F; Writeable (non-executable segments)</span><br><span class="line">#define STA_R       0x2     &#x2F;&#x2F; Readable (executable segments)</span><br><span class="line">#define STA_A       0x1     &#x2F;&#x2F; Accessed</span><br></pre></td></tr></table></figure>
<p>这里代码段和数据段的段基地址都是 0x0, 也就是把他们混在一起了. 可寻址的空间都是 4Gb大小.</p>
<h3 id="3-3-如何使能和进入保护模式">3.3 如何使能和进入保护模式</h3>
<p>紧跟在 gdt表的初始化之后, 就开始进入保护模式.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	# Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">	movl %cr0, %eax  # 把cr0传给 eax</span><br><span class="line">    orl $CR0_PE_ON, %eax </span><br><span class="line">    movl %eax, %cr0laylasi # 将cr0的第一位设置为1 </span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg      # CS的段选择子为0x8</span><br><span class="line"></span><br><span class="line">.code32                                             # 32位模式 Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # 保护模式段寄存器. 也就是把段选择子存进去. 代码段选择子为0x10. 16个字节的位置.</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析上面代码, 可以看到进入保护模式的过程为</p>
<ol>
<li>将 cr0 寄存器的第0位设置为1</li>
<li>使用长跳转命令进入 32位模式</li>
<li>设置初始寄存器的值, 设置栈空间为 0-0x7c00</li>
<li>调用bootmain</li>
</ol>
<p>在段映射过程中, 根据指令的类型产生段选择子, 到gdt中寻找段基地址后加上逻辑地址即可得到线性地址.</p>
<p>关于CS,DS,ES,FS.. 这些段寄存器, 他们实际上有96位, 包含段选择子和对应的段描述符的内容. 这样当我们要访问某些段的时候, 可以直接访问这些寄存器, 而不需要再去访问gdt, 就加速了访问速度.</p>
<div STYLE="page-break-after: always;"></div>
<h2 id="4-分析bootloader加载ELF格式的OS的过程">4. 分析bootloader加载ELF格式的OS的过程</h2>
<p>通过阅读bootmain.c, 了解bootloader如何加载ELF文件. 通过分析源代码和通过qemu来运行并调试 bootloader&amp;OS, 了解</p>
<ol>
<li>bootloader如何读取硬盘扇区的 ?</li>
<li>bootloader是如何加载ELF格式的OS ?</li>
</ol>
<p>提示：可阅读“硬盘访问概述”，“ELF执行文件格式概述”这两小节.</p>
<h3 id="4-1-硬盘CHS和LBA">4.1 硬盘CHS和LBA</h3>
<p>硬盘寻址需要知道扇区, 柱面和磁头. 早期有CHS的寻址方式, 其使用8bit来存储磁头地址, 10bit来存储柱面地址，用6bit来存储扇区地址. 但其寻址空间不足, 于是有了LBA模式作为其改进.</p>
<p>在LBA模式下，系统把所有的物理扇区都按照某种方式或规则看做是一线性编号的扇区,即从0到某个最大值方式排列,并连成一条线,把LBA作为一个整体来对待,而不再是具体到实际的C/H/S值,这样只用一个序数就能确定一个唯一的物理扇区,这就是线性地址的由来，显然线性地址是物理扇区的逻辑地址.</p>
<p>LBA的公式也很好理解. 用C表示当前柱面号, CS表示起始柱面号. H表示当前磁头号, HS表示起始磁头号. S表示当前扇区号, SS表示起始扇区号.PS表示每磁道有多少个扇区,PH表示每柱面有多少个磁道,计算公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>B</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><mtext>–</mtext><mi>C</mi><mi>S</mi><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mi>H</mi><mo>×</mo><mi>P</mi><mi>S</mi><mo>+</mo><mo stretchy="false">(</mo><mi>H</mi><mtext>–</mtext><mi>H</mi><mi>S</mi><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mi>S</mi><mo>+</mo><mo stretchy="false">(</mo><mi>S</mi><mtext>–</mtext><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LBA = ( C – CS ) \times PH \times PS + ( H – HS ) \times PS + ( S – SS )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></span></p>
<p>LBA总共有28位, 可以访问137G的空间.</p>
<p>bootloader的访问硬盘都是LBA模式的PIO(Program IO)方式,即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成.</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406223816554.png" alt="image-20210406223816554" style="zoom:50%;" />
<h3 id="4-2-bootloader如何读取硬盘扇区的">4.2 bootloader如何读取硬盘扇区的?</h3>
<p>当前硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节.读一个扇区的流程大致如下：</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// 读取一个扇区</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);              <span class="comment">// 地址的0-7位</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);       <span class="comment">// 地址的8-15位</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);      <span class="comment">// 地址的16-23位</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>); <span class="comment">//地址的24-27位</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);  <span class="comment">// 一个扇区大小 SECTSIZE = 512byte是. insl以4bytes为单位读入.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 waitdisk() 函数用来等待硬盘空闲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* waitdisk - wait for disk ready */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)  <span class="comment">//从0x1F7中读取状态. 要读到0x1x 这个状态</span></span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后它又封装了一个函数, 能够读取任意长度的内容.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123; <span class="comment">//三个参数分别是, 目的地址, 读取的字节数, 和磁盘地址.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-bootloader是如何加载ELF格式的OS">4.3 bootloader是如何加载ELF格式的OS ?</h3>
<p>分析如下函数</p>
<ol>
<li>
<p>读取ELF头部, 判断是否合法.</p>
</li>
<li>
<p>读取ELF的代码段, 载入内存.</p>
</li>
<li>
<p>把控制权交给操作系统.</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取头部</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>); <span class="comment">//读取 512 * 8 bytes字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取代码段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span> <span class="comment">//指向prog header的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 移交控制权</span></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------EFL 头文件 ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_MAGIC    0x464C457FU            <span class="comment">// &quot;\x7FELF&quot; in little endian</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 1=relocatable, 2=executable, 3=shared object, 4=core image</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 3=x86, 4=68K, etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// file version, always 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// entry point if executable</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// file position of program header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// file position of section header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// architecture-specific flags, usually 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// size of this elf header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// size of an entry in program header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// number of entries in program header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// size of an entry in section header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// number of entries in section header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// section number that contains section name strings</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* program section header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// loadable code or data, dynamic linking info,etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// file offset of segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// virtual address to map segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// physical address, not used</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// size of segment in file</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// read/write/execute bits</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// required alignment, invariably hardware page size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>
<h2 id="5-实现函数调用堆栈跟踪函数">5. 实现函数调用堆栈跟踪函数</h2>
<p>我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函 数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在lab1中执行 “make qemu”后，在qemu模拟器中 得到类似如下的输出：</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406224804080.png" alt="image-20210406224804080" style="zoom:50%;" />
<p>请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。</p>
<p>提示： 可阅读小节“函数堆栈”, 了解编译器如何建立函数调用关系的. 在完成lab1编译后, 查看 lab1/obj/bootblock.asm, 了解bootloader源码与机器码的语句和地址等的对应关系; 查看 lab1/obj/kernel.asm, 了解 ucore OS源码与机器码的语句和地址等的对应关系。</p>
<p>要求完成函数kern/debug/kdebug.c::print_stackframe的实现, 提交改进后源代码包(可以编译执行), 并在实验报告中简要说明实现过程, 并写出对上述问题的回答.</p>
<p>补充材料：由于显示完整的栈结构需要解析内核文件中的调试符号, 较为复杂和繁琐. 代码中有一些辅助函数可以使用. 例如可以通过调用print_debuginfo函数完成查找对应函数名并打印至屏幕的功能. 具体可以参见kdebug.c代码中的注释.</p>
<h3 id="5-1-实现">5.1 实现</h3>
<p>理解一下ebp和esp的作用就很好做了.</p>
<p>esp一直指向栈顶. ebp指向 当前函数调用栈的基地址.</p>
<p>每一次调用函数的开头都要保存之前的 ebp, 并把ebp指向当前函数的基地址, 也就是此时的esp.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl %esp , %ebp</span><br></pre></td></tr></table></figure>
<p>因为在一个函数调用中ebp一直是不懂的, 所以通过ebp可以方便的访问函数的参数.</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406231131725.png" alt="image-20210406231131725" style="zoom:50%;" />
<blockquote>
<p>一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层ebp值。由于ebp中的地址处总是“上一层函数调用时的ebp值”，而在每一层函数调用中，都能通过当时的ebp值“向上（栈底方向）”能获取返回地址、参数值，“向下（栈顶方向）”能获取函数局部变量值。如此形成递归，直至到达栈底。这就是函数调用栈。 —“ucore 实验指导书”</p>
</blockquote>
<p>整个过程是一个往回递归的过程.</p>
<ol>
<li>取得当前的 ebp 和 eip</li>
<li>打印参数</li>
<li>将ebp指向上一个函数的ebp, eip指向返回地址.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * print_stackframe - print a list of the saved eip values from the nested &#x27;call&#x27;</span></span><br><span class="line"><span class="comment"> * instructions that led to the current point of execution</span></span><br><span class="line"><span class="comment"> * The inline function read_ebp() can tell us the value of current ebp. And the</span></span><br><span class="line"><span class="comment"> * non-inline function read_eip() is useful, it can read the value of current eip,</span></span><br><span class="line"><span class="comment"> * since while calling this function, read_eip() can read the caller&#x27;s eip from</span></span><br><span class="line"><span class="comment"> * stack easily.</span></span><br><span class="line"><span class="comment"> * In print_debuginfo(), the function debuginfo_eip() can get enough information about</span></span><br><span class="line"><span class="comment"> * calling-chain. Finally print_stackframe() will trace and print them for debugging.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping</span></span><br><span class="line"><span class="comment"> * to the kernel entry, the value of ebp has been set to zero, that&#x27;s the boundary.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip(); <span class="comment">//获得初始的ebp,eip</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; STACKFREAM_DEPTH &amp;&amp; ebp != <span class="number">0</span>; i++) <span class="comment">//  #define STACKFRAME_DEPTH 20 最多调用20个函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x &quot;</span>, ebp, eip); <span class="comment">//打印值</span></span><br><span class="line">        <span class="keyword">uint32_t</span> *args = ebp + <span class="number">8</span>; <span class="comment">//+4是返回地址, +8是参数</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>, args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">        eip =  *(<span class="keyword">uint32_t</span> *)(ebp + <span class="number">4</span>); <span class="comment">//返回地址</span></span><br><span class="line">        ebp = *(<span class="keyword">uint32_t</span> *)ebp; <span class="comment">// ebp指向的是上一个函数的ebp. 所以用上一个函数的ebp覆盖他</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------ 用到的函数 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span></span><br><span class="line">read_eip(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl 4(%%ebp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (eip))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> eip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">read_ebp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (ebp))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ebp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * print_debuginfo - read and print the stat information for the address @eip,</span></span><br><span class="line"><span class="comment"> * and info.eip_fn_addr should be the first address of the related function.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_debuginfo(<span class="keyword">uintptr_t</span> eip) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debuginfo_eip(eip, &amp;info) != <span class="number">0</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;</span>, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> fnname[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到对应结果</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210406233439403.png" alt="image-20210406233439403" style="zoom:50%;" />
<p>其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   kern/debug/kdebug.c:<span class="number">306</span>: print_stackframe+<span class="number">21</span></span><br><span class="line"><span class="comment">// 调用的文件            所在的行号  栈内偏移量</span></span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>
<h2 id="6-完善中断初始化和处理">6. 完善中断初始化和处理</h2>
<p>请完成编码工作和回答如下问题：</p>
<ol>
<li>
<p>中断描述符表 (也可简称为保护模式下的中断向量表) 中一个表项占多少字节? 其中哪几位代表中断处理代码的入口?</p>
</li>
<li>
<p>请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init. 在idt_init函数中, 依次对所有中断入口进行初始化. 使用mmu.h中的SETGATE宏，填充idt数组内容. 每个中断的入口由 tools/vectors.c生成, 使用trap.c中声明的vectors数组即可.</p>
</li>
<li>
<p>请编程完善trap.c中的中断处理函数trap, 在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分, 使操作系统每遇到100次时钟中断后, 调用print_ticks子程序, 向屏幕上打印一行文字 ”100 ticks”.</p>
<blockquote>
<p>【注意】除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权 限；而ucore的应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件中断，Tra中断，在lab5会碰到）来发出系统调用请 求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。</p>
</blockquote>
</li>
</ol>
<p>要求完成问题2和问题3 提出的相关函数实现, 提交改进后的源代码包(可以编译执行), 并在实验报告中简要说明实现过程, 并写出对问题1的回答. 完成这问题2和3要求的部分代码后, 运行整个系统, 可以看到大约每1秒会输出一 次”100 ticks”, 而按下的键也会在屏幕上显示.</p>
<p>提示：可阅读小节“中断与异常”。</p>
<h3 id="6-1-中断描述符表-也可简称为保护模式下的中断向量表-中一个表项占多少字节-其中哪几位代表中断处理代码的入口">6.1 中断描述符表 (也可简称为保护模式下的中断向量表) 中一个表项占多少字节? 其中哪几位代表中断处理代码的入口?</h3>
<ul>
<li>
<p>中断：</p>
<p>CPU一边执行指令, 一边监听着外部事件, 当外部事件发生时, 停下手里的活先去处理外部事件。</p>
<p>CPU设置两根中断输入线来相应两个类型的中断</p>
<ul>
<li>
<p>可屏蔽中断 INTR</p>
<p>CPU可以选择响应. 可以通过IF标志位屏蔽</p>
</li>
<li>
<p>不可屏蔽中断 NIM</p>
<p>CPU必须无条件响应. 如断电</p>
</li>
</ul>
<p>异常：</p>
<p>​	CPU执行指令过程中产生了错误， 也叫软中断，CPU必须无条件响应。</p>
<p>​	常见的有除0，页面故障。</p>
<p>区别：</p>
<p>​	中断是一个异步的过程。 异常是同步的过程， 可复现。</p>
</li>
<li>
<p>中断描述表：</p>
<p>中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描<br>
述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号乘以8做为IDT的索引。IDT可以位于内存的任<br>
意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都<br>
有一个显示的操作数：一个6字节表示的内存地址。指令的含义如下：</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359" alt="img" style="zoom: 80%;" />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_15_0 : <span class="number">16</span>;        <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_args : <span class="number">5</span>;            <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_rsv1 : <span class="number">3</span>;            <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_type : <span class="number">4</span>;            <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_s : <span class="number">1</span>;                <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_p : <span class="number">1</span>;                <span class="comment">// Present</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_31_16 : <span class="number">16</span>;        <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>中断寄存器IDTR</p>
<p>存储着IDT在内存中的位置</p>
<p><img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100855453" alt="img"></p>
</li>
<li>
<p>过程</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/b4d97a164e0730085fbb5f839e393c9e_r.jpg" alt="img" style="zoom:50%;" />
<ol>
<li>产生中断, CPU获得中断号, 到IDT中找到对应的中断描述.</li>
<li>根据中断描述符中的段选择子, 到GDT或者LDT中找到段基地址</li>
<li>将段基地址加上描述符中的偏移量, 就得到中断服务例程的地址, 执行中断服务.</li>
<li>执行服务之前会比较一下特权级(中断总是内核态的). 如果发生了特权级的转变要保存用户态的ss和esp寄存器.</li>
<li>将中断程序使用的eflags,cs,eip, errorcode(如果有的话)压栈,以便之后恢复该程序.</li>
<li>中断服务例程在处理完成之后通过iret指令弹出保存在栈中的信息,并跳转到被中断的程序继续执行.</li>
</ol>
<p>在trap.h 函数中可以看到trapframe的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-2-编程完善kern-trap-trap-c中对中断向量表进行初始化的函数idt-init">6.2 编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></span><br><span class="line"><span class="comment">      *     All ISR&#x27;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span></span><br><span class="line"><span class="comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span></span><br><span class="line"><span class="comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span></span><br><span class="line"><span class="comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span></span><br><span class="line"><span class="comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT</span></span><br><span class="line"><span class="comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction.</span></span><br><span class="line"><span class="comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++) &#123; <span class="comment">//IDT表项的个数</span></span><br><span class="line">        <span class="comment">// 在中断门描述符表中通过建立中断门描述符，其中存储了中断处理例程的代码段GD_KTEXT和偏移量__vectors[i]，特权级</span></span><br><span class="line">        <span class="comment">// 为DPL_KERNEL。这样通过查询idt[i]就可定位到中断服务例程的起始地址。</span></span><br><span class="line">            SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">    <span class="comment">//建立好中断门描述符表后，通过指令lidt把中断门描述符表的起始地址装入IDTR寄存器中，从而完成中段描述符表的初始化工作。</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------用的一些定义---------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置IDTR寄存器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">lidt(struct pseudodesc *pd) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lidt (%0)&quot;</span> :: <span class="string">&quot;r&quot;</span> (pd))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */</span></span><br><span class="line"><span class="comment">// 48位的IDTR结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pd_lim;         <span class="comment">// Limit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pd_base;        <span class="comment">// Base address</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">idt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)idt <span class="comment">//大小, 地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Interrupt descriptor table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be built at run time because shifted function addresses can&#x27;t</span></span><br><span class="line"><span class="comment"> * be represented in relocation records.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256] =</span> &#123;&#123;<span class="number">0</span>&#125;&#125;;  <span class="comment">// 定义idt表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Set up a normal interrupt/trap gate descriptor</span></span><br><span class="line"><span class="comment"> *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate</span></span><br><span class="line"><span class="comment"> *   - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - dpl: Descriptor Privilege Level - the privilege level required</span></span><br><span class="line"><span class="comment"> *          for software to invoke this interrupt/trap gate explicitly</span></span><br><span class="line"><span class="comment"> *          using an int instruction.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>)(off) &amp; <span class="number">0xffff</span>;        \</span><br><span class="line">    (gate).gd_ss = (sel);                                \</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                                \</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;                                    \</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>)(off) &gt;&gt; <span class="number">16</span>;        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vecotr.S(由vector.c生成)中查看 __vectors[] 的定义, 发现他是一个大小为256long的数组, 里面存的是中断处理例程的地址.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vector table</span><br><span class="line">.data # 数据段</span><br><span class="line">.globl __vectors #告诉汇编器要被链接器用到</span><br><span class="line">__vectors:</span><br><span class="line">  .long vector0</span><br><span class="line">  .long vector1</span><br><span class="line">  .long vector2</span><br><span class="line">  .long vector3</span><br><span class="line">  .long vector4</span><br><span class="line">  .long vector5</span><br><span class="line">  .long vector6</span><br><span class="line">  .long vector7</span><br><span class="line">  .long vector8</span><br><span class="line">  .long vector9</span><br><span class="line">  .long vector10</span><br><span class="line">  # .......</span><br></pre></td></tr></table></figure>
<p>其中的 vector 是代码段, 即中断处理例程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text  #表示这是一个代码段</span><br><span class="line">.globl __alltraps  </span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $0</span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector1</span><br><span class="line">vector1:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $1</span><br><span class="line">  jmp __alltraps</span><br></pre></td></tr></table></figure>
<p>所有的中断都通过 __alltraps 函数来处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vectors.S sends all traps here.</span><br><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # push registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA into %ds and %es to set up data segments for kernel</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # push %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf&#x3D;%esp</span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line">    # pop the pushed stack pointer</span><br><span class="line">    popl %esp</span><br></pre></td></tr></table></figure>
<h3 id="6-3-编程完善trap-c中的中断处理函数trap">6.3 编程完善trap.c中的中断处理函数trap.</h3>
<p>处理一下时钟中断即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span>(++ticks == TICK_NUM):</span><br><span class="line">            &#123;</span><br><span class="line">            	print_ticks();</span><br><span class="line">            	ticks = <span class="number">0</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用到了打印时钟函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_ticks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;%d ticks\n&quot;</span>,TICK_NUM);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 函数调用:  中断 -&gt; idt table -&gt; __alltraps -&gt; trap -&gt; trap_dispatch</span></span><br></pre></td></tr></table></figure>
<p>接下来看一下一些变量的定义.</p>
<p>ticks是<strong>时钟中断计数器</strong>, 每一百次时钟中断调用一次print_ticks函数. 其的定义在 clock.c 里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">size_t</span> ticks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * clock_init - initialize 8253 clock to interrupt 100 times per second,</span></span><br><span class="line"><span class="comment"> * and then enable IRQ_TIMER.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">clock_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// set 8253 timer-chip</span></span><br><span class="line">    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);</span><br><span class="line">    outb(IO_TIMER1, TIMER_DIV(<span class="number">100</span>) % <span class="number">256</span>);</span><br><span class="line">    outb(IO_TIMER1, TIMER_DIV(<span class="number">100</span>) / <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize time counter &#x27;ticks&#x27; to zero</span></span><br><span class="line">    ticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;++ setup timer interrupts\n&quot;</span>);</span><br><span class="line">    pic_enable(IRQ_TIMER);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的pic_enable(IRQ_TIMER) 是在使能时钟中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pic_setmask(<span class="keyword">uint16_t</span> mask) &#123;</span><br><span class="line">    irq_mask = mask;</span><br><span class="line">    <span class="keyword">if</span> (did_init) &#123;</span><br><span class="line">        outb(IO_PIC1 + <span class="number">1</span>, mask);</span><br><span class="line">        outb(IO_PIC2 + <span class="number">1</span>, mask &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pic_enable(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq) &#123;</span><br><span class="line">    pic_setmask(irq_mask &amp; ~(<span class="number">1</span> &lt;&lt; irq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的效果是每隔一秒触发一次</p>
<img src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20210407091117669.png" alt="image-20210407091117669" style="zoom:50%;" />
<ul>
<li>
<p>问题</p>
<p>一开始不明白时钟中断是哪里来的..</p>
<blockquote>
<p>周期性产生的时钟中断是由系统定时器(硬件)驱动的, 它以固定频率产生时钟中断.</p>
</blockquote>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">实验目的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bootloader%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">bootloader是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%90%86%E8%A7%A3%E9%80%9A%E8%BF%87make%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">1. 理解通过make生成执行文件的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6"><span class="toc-text">项目框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%85%E8%AF%BBmakefile"><span class="toc-text">阅读makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kernel"><span class="toc-text">kernel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bootblock"><span class="toc-text">bootblock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94"><span class="toc-text">1.3 问题回答</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8qemu%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95"><span class="toc-text">2. 使用qemu软件调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-QEMU%E8%B0%83%E8%AF%95"><span class="toc-text">2.1 QEMU调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%8ECPU%E5%8A%A0%E7%94%B5%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%BC%80%E5%A7%8B-%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AABIOS%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text">2.2 从CPU加电后执行的第一条指令开始,单步跟踪BIOS的执行.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BD%8D%E7%BD%AE0x7c00%E8%AE%BE%E7%BD%AE%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%96%AD%E7%82%B9-%E6%B5%8B%E8%AF%95%E6%96%AD%E7%82%B9%E6%AD%A3%E5%B8%B8"><span class="toc-text">2.3 在初始化位置0x7c00设置实地址断点, 测试断点正常.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%8E0x7c00%E5%BC%80%E5%A7%8B%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C-%E5%B0%86%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BE%97%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8Ebootasm-S%E5%92%8C-bootblock-asm%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-text">2.4 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%87%AA%E5%B7%B1%E6%89%BE%E4%B8%80%E4%B8%AAbootloader%E6%88%96%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE-%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">2.5 自己找一个bootloader或内核中的代码位置,设置断点并进行测试.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E6%9E%90-bootloader-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">3. 分析 bootloader 进入保护模式的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E4%B8%BA%E4%BD%95%E5%BC%80%E5%90%AFA20-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFA20"><span class="toc-text">3.1为何开启A20, 以及如何开启A20</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96GDT%E8%A1%A8"><span class="toc-text">3.2 如何初始化GDT表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E8%83%BD%E5%92%8C%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.3 如何使能和进入保护模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90bootloader%E5%8A%A0%E8%BD%BDELF%E6%A0%BC%E5%BC%8F%E7%9A%84OS%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">4. 分析bootloader加载ELF格式的OS的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%A1%AC%E7%9B%98CHS%E5%92%8CLBA"><span class="toc-text">4.1 硬盘CHS和LBA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-bootloader%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E6%89%87%E5%8C%BA%E7%9A%84"><span class="toc-text">4.2 bootloader如何读取硬盘扇区的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-bootloader%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDELF%E6%A0%BC%E5%BC%8F%E7%9A%84OS"><span class="toc-text">4.3 bootloader是如何加载ELF格式的OS ?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-text">5. 实现函数调用堆栈跟踪函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.1 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-text">6. 完善中断初始化和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8-%E4%B9%9F%E5%8F%AF%E7%AE%80%E7%A7%B0%E4%B8%BA%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82-%E5%85%B6%E4%B8%AD%E5%93%AA%E5%87%A0%E4%BD%8D%E4%BB%A3%E8%A1%A8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text">6.1 中断描述符表 (也可简称为保护模式下的中断向量表) 中一个表项占多少字节? 其中哪几位代表中断处理代码的入口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%96%E7%A8%8B%E5%AE%8C%E5%96%84kern-trap-trap-c%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%87%BD%E6%95%B0idt-init"><span class="toc-text">6.2 编程完善kern&#x2F;trap&#x2F;trap.c中对中断向量表进行初始化的函数idt_init.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%BC%96%E7%A8%8B%E5%AE%8C%E5%96%84trap-c%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0trap"><span class="toc-text">6.3 编程完善trap.c中的中断处理函数trap.</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #D5F3F4"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By qwqbot</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>