<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>图论 | qwqbot</title><meta name="author" content="qwqbot"><meta name="copyright" content="qwqbot"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络流 [TOC] 最大流&#x2F;最小割 Dinic #include &lt;bits&#x2F;stdc++.h&gt;using namespace std;namespace dinic &amp;#123;    using T &#x3D; long long;    const int EDGE &#x3D; 600005;const T INF &#x3D; 0x3f3f3f3f3f3f3f3f;const int V &#x3D; 2005;">
<meta property="og:type" content="article">
<meta property="og:title" content="图论">
<meta property="og:url" content="http://qwqbot.com/ACM/Template/ACM/Template/%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="qwqbot">
<meta property="og:description" content="网络流 [TOC] 最大流&#x2F;最小割 Dinic #include &lt;bits&#x2F;stdc++.h&gt;using namespace std;namespace dinic &amp;#123;    using T &#x3D; long long;    const int EDGE &#x3D; 600005;const T INF &#x3D; 0x3f3f3f3f3f3f3f3f;const int V &#x3D; 2005;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&Lowell.jpg">
<meta property="article:published_time" content="2021-07-31T03:52:15.432Z">
<meta property="article:modified_time" content="2021-11-12T15:12:41.145Z">
<meta property="article:author" content="qwqbot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&Lowell.jpg"><link rel="shortcut icon" href="/img/qwq_circle2.jpg"><link rel="canonical" href="http://qwqbot.com/ACM/Template/ACM/Template/%E5%9B%BE%E8%AE%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-12 23:12:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/qwq_circle2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&amp;Lowell.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qwqbot</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-31T03:52:15.432Z" title="发表于 2021-07-31 11:52:15">2021-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-12T15:12:41.145Z" title="更新于 2021-11-12 23:12:41">2021-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/">ACM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/Template/">Template</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>网络流</h1>
<p>[TOC]</p>
<h2 id="最大流-最小割">最大流/最小割</h2>
<h3 id="Dinic">Dinic</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dinic &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> EDGE = <span class="number">600005</span>;</span><br><span class="line"><span class="keyword">const</span> T INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> next, to;</span><br><span class="line">  T cap;</span><br><span class="line">&#125; e[EDGE];</span><br><span class="line"><span class="keyword">int</span> cnt, head[V], cur[V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, T cap)</span> </span>&#123;</span><br><span class="line">  e[cnt].to = to, e[cnt].cap = cap, e[cnt].next = head[from];</span><br><span class="line">  head[from] = cnt++;</span><br><span class="line">  e[cnt].to = from, e[cnt].cap = <span class="number">0</span>, e[cnt].next = head[to];</span><br><span class="line">  head[to] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span>  <span class="comment">//建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[V], pre[V];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分层 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">  <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">  Q.push(s);</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  pre[s] = pre[t] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> now = Q.front();</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (e[i].cap &amp;&amp; d[to] == <span class="number">-1</span>) &#123;</span><br><span class="line">        pre[to] = i;</span><br><span class="line">        d[to] = d[now] + <span class="number">1</span>;</span><br><span class="line">        Q.push(to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多路增广, 适用于稠密图 */</span></span><br><span class="line"><span class="function">T <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t, T limit)</span>  <span class="comment">//在一条路上,limit是单调递减的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!limit || x == t)  <span class="comment">// 如果限制为0了, 或者到t了返回</span></span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">  T flow = <span class="number">0</span>, nf = <span class="number">0</span>;  <span class="comment">// flow 是当前点后面总共的流量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">    cur[x] = i;  <span class="comment">//当前弧优化. 如果这次跑到了这条弧, 那么下一次从这条开始即可,</span></span><br><span class="line">                 <span class="comment">//因为之前都跑满了.</span></span><br><span class="line">    <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (d[to] == d[x] + <span class="number">1</span> &amp;&amp; e[i].cap &amp;&amp;</span><br><span class="line">        (nf = Dfs(to, t, min(limit, e[i].cap)))) &#123;</span><br><span class="line">      limit -= nf;</span><br><span class="line">      flow += nf;</span><br><span class="line">      e[i].cap -= nf;</span><br><span class="line">      e[i ^ <span class="number">1</span>].cap += nf;</span><br><span class="line">      <span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单路增广, 适用于边容量很小的图 */</span></span><br><span class="line"><span class="function">T <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  T limit = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">    limit = min(limit, e[pe].cap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">    e[pe].cap -= limit;</span><br><span class="line">    e[pe ^ <span class="number">1</span>].cap += limit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  T ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (Bfs(s, t)) &#123;</span><br><span class="line">    <span class="comment">// dinic 算法</span></span><br><span class="line">    <span class="comment">// ans += Dfs(s, t, 0x3f3f3f3f3f3f3f3f);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EK 算法</span></span><br><span class="line">    ans += EK(s, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;  <span class="comment">// ans是最大流, res 才是费用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;  <span class="comment">// namespace dinic</span></span><br></pre></td></tr></table></figure>
<h2 id="最小割">最小割</h2>
<p>割的两种表述:</p>
<ol>
<li>割是一些边集, 拿走这些边之后不存在一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>​ 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​​​ 的路径.  也就是任意一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>​ 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​ 的路径, 至少有一条边在割中.</li>
<li>割是把所有点分成两个点集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>. 其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</li>
</ol>
<p>最小割是所有割中容量最小的割.</p>
<ul>
<li>
<p>最大流最小割定理</p>
<p>最大流等于最小割. 此时图中不存在一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的路径.</p>
</li>
<li>
<p>最小割方案</p>
<p>跑完网络流之后, 看 <code>bfs</code> 的距离数组中距离不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的边, 即为割点集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中的点的连出这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的并且满流的边就是割边.</p>
</li>
</ul>
<h3 id="可行边-必须边">可行边/必须边</h3>
<ul>
<li>
<p>最小割可行边 = 最大流一定满流的边</p>
<p>边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 被某个最小割包含, 等价于 减小该边的容量之后 最小割减小(即最大流也一定减小)</p>
<ol>
<li>满流</li>
<li>在残留网络中, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>​ 不在一个强连通分量中</li>
</ol>
<p>注意只判断第二个条件是不够的, 因为没有满流可能是空流, 那么此时第二个条件也会满足.</p>
</li>
<li>
<p>最小割必须边</p>
<p>边 $(u,v) $ 在所有最小割中, 必须满足增大该边的容量之后最小割增大.</p>
<ol>
<li>满流</li>
<li>在残留网络中, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 可以到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 可以到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</li>
</ol>
<p>第二条件等价于判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 在一个强连通分量, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 在一个强连通分量.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tarjan</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// const int V = ;</span></span><br><span class="line">    <span class="keyword">bool</span> instack[V];</span><br><span class="line">    <span class="keyword">int</span> scc[V], szscc[V], _sc;</span><br><span class="line">    <span class="keyword">int</span> dfn[V], low[V], _dfn;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[u] = ++_dfn;</span><br><span class="line">        low[u] = dfn[u];</span><br><span class="line">        instack[u] = <span class="literal">true</span>;</span><br><span class="line">        s.push(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].cap == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">                dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (instack[v])</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u])</span><br><span class="line">        &#123;</span><br><span class="line">            _sc++;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                scc[x] = _sc;</span><br><span class="line">                szscc[x]++;</span><br><span class="line">                instack[x] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SCC</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line">Dinic::e[(i - <span class="number">1</span>) * <span class="number">2</span>].cap != <span class="number">0</span></span><br><span class="line">Dinic::Tarjan::scc[u] != Dinic::Tarjan::scc[v]</span><br><span class="line">(Dinic::Tarjan::scc[s] == Dinic::Tarjan::scc[u]) &amp;&amp; (Dinic::Tarjan::scc[t] == Dinic::Tarjan::scc[v])</span><br></pre></td></tr></table></figure>
<h3 id="平面图转对偶图">平面图转对偶图</h3>
<img src= "/img/loading.gif" data-lazy-src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20211112213613861.png" alt="image-20211112213613861" style="zoom: 33%;" />
<p>求左上角到右下角的最小割, 等价于求左下角到右上角的最短路.</p>
<ul>
<li>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ppi pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[N], pre[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ppi&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">  d[s] = <span class="number">0</span>;  <span class="comment">//记当前最短距离</span></span><br><span class="line">  <span class="built_in">priority_queue</span>&lt;ppi, <span class="built_in">vector</span>&lt;ppi&gt;, greater&lt;ppi&gt;&gt; v;</span><br><span class="line">  v.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">  <span class="keyword">while</span> (!v.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = v.top().second;</span><br><span class="line">    v.pop();</span><br><span class="line">    <span class="keyword">if</span> (vis[head])  <span class="comment">//已经在S中了,说明是之前松弛的,直接跳过</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    vis[head] = <span class="literal">true</span>;        <span class="comment">//标记在 S 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[head])  <span class="comment">//遍历邻居结点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[to.first]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (d[to.first] &gt; d[head] + to.second) &#123;</span><br><span class="line">        d[to.first] = d[head] + to.second;</span><br><span class="line">        v.push(<span class="built_in">make_pair</span>(d[to.first], to.first));</span><br><span class="line">        pre[to.first] = head;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> s = (n - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> t = (n - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第一行横向边 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">    <span class="keyword">int</span> u = t;</span><br><span class="line">    <span class="keyword">int</span> v = j * <span class="number">2</span>;</span><br><span class="line">    g[u].emplace_back(v, val);</span><br><span class="line">    g[v].emplace_back(u, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2 到 n - 1 行的横向边 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">      <span class="keyword">int</span> u = (i - <span class="number">2</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + (j * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> v = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + (j * <span class="number">2</span>);</span><br><span class="line">      g[u].emplace_back(v, val);</span><br><span class="line">      g[v].emplace_back(u, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后一行横向边 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">int</span> v = (n - <span class="number">2</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + (j * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    g[u].emplace_back(v, val);</span><br><span class="line">    g[v].emplace_back(u, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 纵向边 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">      <span class="keyword">int</span> u, v;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        u = s;</span><br><span class="line">        v = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        u = t;</span><br><span class="line">        v = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + ((m - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + (j * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        v = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + ((j - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      g[u].emplace_back(v, val);</span><br><span class="line">      g[v].emplace_back(u, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 斜向边 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">      <span class="keyword">int</span> u = (i - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + j * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> v = u - <span class="number">1</span>;</span><br><span class="line">      g[u].emplace_back(v, val);</span><br><span class="line">      g[v].emplace_back(u, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dijkstra(s);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; d[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="最小费用最大流">最小费用最大流</h2>
<ul>
<li>
<p><code>spfa</code> 版本</p>
<p>多路增广的适合流量大的时候.</p>
<p>单路增广的适合流量小的时候.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> dinic &#123;</span><br><span class="line"><span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">605</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> EDGE = V * V + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> next, to;</span><br><span class="line">  <span class="keyword">int</span> cap;</span><br><span class="line">  T cost;</span><br><span class="line">&#125; e[EDGE];</span><br><span class="line"><span class="keyword">int</span> cnt, head[V];</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;  <span class="comment">// spfa</span></span><br><span class="line"><span class="keyword">bool</span> vis[V];   <span class="comment">// spfa(不需memset) 和 dfs避免环</span></span><br><span class="line"><span class="keyword">int</span> pre[V];    <span class="comment">// 记录点的前驱边</span></span><br><span class="line">T d[V];        <span class="comment">// 距离</span></span><br><span class="line">T res;         <span class="comment">//记录费用</span></span><br><span class="line"><span class="keyword">int</span> cur[V];    <span class="comment">// dinic 算法的当前弧优化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, T cost)</span> </span>&#123;</span><br><span class="line">  e[cnt].to = to, e[cnt].cap = cap, e[cnt].cost = cost,</span><br><span class="line">  e[cnt].next = head[from];</span><br><span class="line">  head[from] = cnt++;</span><br><span class="line">  e[cnt].to = from, e[cnt].cap = <span class="number">0</span>, e[cnt].cost = -cost, e[cnt].next = head[to];</span><br><span class="line">  head[to] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span>  <span class="comment">//建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res = cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  <span class="comment">//对残留网络分层</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dinic 的当前弧优化</span></span><br><span class="line">  <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// EK 算法</span></span><br><span class="line">  pre[s] = pre[t] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  Q.push_back(s);</span><br><span class="line">  d[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> now = Q.front();</span><br><span class="line">    Q.pop_front();</span><br><span class="line">    vis[now] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e[i].cap == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (d[to] &gt; d[now] + e[i].cost) &#123;</span><br><span class="line">        d[to] = d[now] + e[i].cost;</span><br><span class="line">        pre[to] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to])  <span class="comment">// 不在队列里则加入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[to] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (Q.empty() || d[to] &lt; d[Q.front()])  <span class="comment">// SLF优化</span></span><br><span class="line">            Q.push_front(to);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            Q.push_back(to);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre[t] != <span class="number">-1</span>;  <span class="comment">// 从 s 到 t 是否存在一条路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多路增广, 适用于稠密图</span></span><br><span class="line"><span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t, <span class="keyword">int</span> limit)</span>  <span class="comment">//在一条路上,limit是单调递减的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!limit || x == t)  <span class="comment">// 如果限制为0了, 或者到t了返回</span></span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">  <span class="keyword">int</span> flow = <span class="number">0</span>, nf = <span class="number">0</span>;  <span class="comment">// flow 是当前点后面总共的流量</span></span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">    cur[x] = i;  <span class="comment">//当前弧优化. 如果这次跑到了这条弧, 那么下一次从这条开始即可,</span></span><br><span class="line">                 <span class="comment">//因为之前都跑满了.</span></span><br><span class="line">    <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (vis[to])  <span class="comment">//这步是为了防止有费用为0的边出现的环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[to] == d[x] + e[i].cost &amp;&amp; e[i].cap &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (nf = dfs(to, t, min(limit, e[i].cap)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nf)  <span class="comment">// 如果还可以流</span></span><br><span class="line">        res += nf * e[i].cost;</span><br><span class="line">      limit -= nf;</span><br><span class="line">      flow += nf;</span><br><span class="line">      e[i].cap -= nf;</span><br><span class="line">      e[i ^ <span class="number">1</span>].cap += nf;</span><br><span class="line">      <span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[x] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单路增广, 适用于边容量很小的图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> limit = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to])  <span class="comment">// 找瓶颈边</span></span><br><span class="line">    limit = min(limit, e[pe].cap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">    res += e[pe].cost * limit;</span><br><span class="line">    e[pe].cap -= limit;</span><br><span class="line">    e[pe ^ <span class="number">1</span>].cap += limit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;T, T&gt; flow(int s, int t) &#123;</span><br><span class="line">  T ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line">    <span class="comment">// 多路增广</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    ans += dfs(s, t, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单路增广</span></span><br><span class="line">    ans += ek(s, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;ans, res&#125;;  <span class="comment">// ans:最大流, res:费用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;  <span class="comment">// namespace dinic</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dijkstra</code> 版本</p>
<p>咕了</p>
</li>
</ul>
<h2 id="最大权闭合子图">最大权闭合子图</h2>
<ul>
<li>
<p>建模</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 连向正权点, 容量为点权. 负权点连向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> , 容量为点权的绝对值. 原图边的容量设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></p>
<p>这样一个点如果选了, 即在割集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中, 那么他连向的点都要在割集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中​.</p>
<p>这样建模之后是一个类似二分图的东西, 割边只能是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 连出来的边和连向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的边.</p>
</li>
<li>
<p>答案</p>
<p>最大权闭合子图是所有<strong>正点权</strong>和减去最小割.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><msup><mi>w</mi><mo lspace="0em" rspace="0em">+</mo></msup><mo>−</mo><mi>c</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(V&#x27;)  = \sum w^{+} - c(S,T)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p>
<p>方案是割集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>​</p>
</li>
</ul>
<h3 id="洛谷-太空飞行计划">洛谷 太空飞行计划</h3>
<img src= "/img/loading.gif" data-lazy-src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/image-20211112231137502.png" alt="image-20211112231137502" style="zoom:33%;" />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] != <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= M + N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] != <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i - M &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pay[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    build();</span><br><span class="line">    s = M + N + <span class="number">1</span>, t = M + N + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        getline(<span class="built_in">cin</span>, a);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(a)</span></span>;</span><br><span class="line">        ss &gt;&gt; pay[i];</span><br><span class="line">        ans += pay[i];</span><br><span class="line">        add_edge(s, i, pay[i]);</span><br><span class="line">        add_edge(i, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> to = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; to)</span><br><span class="line">        &#123;</span><br><span class="line">            add_edge(i, M + to, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">            add_edge(M + to, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pay[i + M];</span><br><span class="line">        add_edge(M + i, t, pay[i + M]);</span><br><span class="line">        add_edge(t, M + i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= dinic(s, t);</span><br><span class="line">    print(M, N);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下界网络流">上下界网络流</h2>
<h3 id="无源汇上下界可行流">无源汇上下界可行流</h3>
<p>给一个没有源点和汇点的网络, 每条边有一个流量上限 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和下限 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 求出一个可行流(循环流).</p>
<h4 id="方法">方法</h4>
<p>先让搞一个初始流, 让每条边的流量等于它的下限.</p>
<p>然后得到一个新的网络, 每条边的流量上下限为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>h</mi><mi>i</mi></msub><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, h_i - l_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>. 因为初始流不满足流量守恒, 也就是说对每个结点, 其要么多流入了一点,要么少流入了一点. 我们考虑在这个新网络上建立一个附加流, 使得原来的流加上这个附加流之后满足流量守恒.</p>
<p>新建一个源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 和 汇点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</p>
<ul>
<li>如果一个点多流入了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 那么在附加流中, 他就要多流出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 要让多流出的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有一个来路, 即从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 连一条容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边.</li>
<li>如果一个点多流出了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 那么他就要多流入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 要让多流入的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有一个去处, 所以向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 连一条容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边.</li>
</ul>
<p>附加流要求这些边一定是满流, 才能满足流量守恒.</p>
<p>指向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的容量和即为初始流中多流出的流量, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 指出来的流量和即为初始流中多流入的流量.</p>
<p>显然两者是相等的.</p>
<p>所以最后跑一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的最大流, 看看是不是满流即可.</p>
<h3 id="有源汇上下界可行流">有源汇上下界可行流</h3>
<p>假设现在有一个源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 和汇点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, 要求一个上下界的可行流, 可以把他转换成无源汇的上下界可行流.</p>
<p>其操作即为从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 连一条容量为无穷大的边, 然后对这个图跑一遍可行流即可.</p>
<h4 id="最大流">最大流</h4>
<p>可行流跑完一遍, 再跑一边 <code>dinic</code> 最大流即可. 可行最大流为可行流跑完后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">t\rightarrow s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 那条边的流量加上后面最大流的流量.</p>
<h4 id="最小流">最小流</h4>
<p>同样的,可行流跑完一遍, 跑一遍从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">t\rightarrow s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 的dinic就行了. 可行最小流为可行流跑完后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">t \rightarrow s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 那条边的流量减去这次最大流的流量就行了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        build();</span><br><span class="line">        s = n + m + <span class="number">1</span>, t = n + m + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ss = n + m + <span class="number">3</span>, tt = n + m + <span class="number">4</span>;  <span class="comment">// 注意区分s,ss,t,tt</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line">            add_edge(i + n, t, inf - l, l); <span class="comment">//下限</span></span><br><span class="line">            add_edge(t, i + n, <span class="number">0</span>, l);</span><br><span class="line">            a[i + n] += l;</span><br><span class="line">            a[t] -= l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c, d;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; d;</span><br><span class="line">            add_edge(s, i, d, <span class="number">0</span>);</span><br><span class="line">            add_edge(i, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> to, l, h;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; to &gt;&gt; l &gt;&gt; h;</span><br><span class="line">                to++;</span><br><span class="line">                add_edge(i, to + n, h - l, l);</span><br><span class="line">                add_edge(to + n, i, <span class="number">0</span>, l);</span><br><span class="line">                a[i] += l;</span><br><span class="line">                a[to + n] -= l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        add_edge(t, s, inf, <span class="number">0</span>);</span><br><span class="line">        add_edge(s, t, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m + <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += a[i];</span><br><span class="line">                add_edge(i, tt, a[i], <span class="number">0</span>);</span><br><span class="line">                add_edge(tt, i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                add_edge(ss, i, -a[i], <span class="number">0</span>);</span><br><span class="line">                add_edge(i, ss, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = dinic(ss, tt);</span><br><span class="line">        <span class="keyword">int</span> x = edge[head[t] + <span class="number">1</span>].cap; <span class="comment">//可行流中从s到t的流量</span></span><br><span class="line">        <span class="keyword">if</span> (ans1 == ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans2 = dinic(s, t);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x + ans2 &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单纯形">单纯形</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">double</span> a[maxm][maxn], basicans[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn]; <span class="comment">//记录最后的方程左边, 是原来的哪个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> e, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(id[n + l], id[e]);</span><br><span class="line">    <span class="keyword">double</span> x = a[l][e];</span><br><span class="line">    a[l][e] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        a[l][i] /= x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == l || <span class="built_in">abs</span>(a[l][e]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">double</span> t = a[i][e];</span><br><span class="line">        a[i][e] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            a[i][j] -= t * a[l][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">simplex</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = -n, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>][i] &gt; eps &amp;&amp; id[i] &lt; id[e]) <span class="comment">//第一个系数大于0的</span></span><br><span class="line">                e = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="comment">// 系数都小于0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> mmin = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][e] &gt; eps)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> x = a[i][<span class="number">0</span>] / a[i][e];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; mmin || (<span class="built_in">abs</span>(x - mmin) &lt; eps &amp;&amp; id[n + i] &lt; id[n + l]))</span><br><span class="line">                    mmin = x, l = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == -n) <span class="comment">// 无界</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pivot(l, e, n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init_simplex</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, l = -n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][<span class="number">0</span>] &lt; -eps &amp;&amp; id[n + i] &lt; id[n + l])</span><br><span class="line">                l = i;</span><br><span class="line">        <span class="keyword">if</span> (l == -n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[l][j] &lt; -eps &amp;&amp; id[j] &lt; id[e])</span><br><span class="line">                e = j;</span><br><span class="line">        <span class="keyword">if</span> (!e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pivot(l, e, n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">        id[i] = i;</span><br><span class="line">    id[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!init_simplex(n, m))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!simplex(n, m))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>二分图</h1>
<ul>
<li>
<p>判定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">void</span> dfs(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    col[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[v] == <span class="number">-1</span>)</span><br><span class="line">            dfs(v, c ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (col[v] == col[u])</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>增广路</p>
<p>起点和终点都是非匹配点, 并且走的边是 非 - 匹 - 非 …. 非.</p>
<p>把增广路中所有的非匹配边换成匹配边, 匹配边换成非匹配边, 仍然是一个匹配, 并且匹配数量加1.</p>
<ol>
<li>有奇数条边. 奇数边是非匹配边.</li>
</ol>
</li>
</ul>
<h2 id="二分图博弈">二分图博弈</h2>
<ul>
<li>定义
<ol>
<li>博弈人数为两人, 双方轮流进行决策.</li>
<li>博弈状态(对应点)可分为两类(状态空间可分为两个集合),对应二分图两边(X 集和 Y 集). 任意合法的决策(对应边)使状态从一类跳转到另一类. (正是由于这个性质使得问题可以用二分图描述).</li>
<li>不可转移至已访问的状态.</li>
<li>无法转移者判负.</li>
</ol>
</li>
</ul>
<h3 id="解法">解法</h3>
<ul>
<li>
<p>先手点若<strong>一定在最大匹配内</strong>, 则先手必胜.</p>
<p>从先手点开始走 匹配边 - 非匹配边 - 匹配边 - …..  最后一定停在右边. 如果停在左边, 路径上匹配边和非匹配边数量相同, 取反后获得一个不包含先手点的最大匹配, 和前提矛盾.</p>
</li>
<li>
<p>若<strong>存在</strong>一个最大匹配, <strong>不包含先手点</strong>, 则先手必败.</p>
<p>在该最大匹配中, 先手点走的增广路只能先走非匹配边, 然后后手选择走匹配边, 这样  非 - 匹 - 非 ….. 匹, 最后一条边是匹配边, 否则会得到一个更大的匹配. 所以最后停在左边.</p>
</li>
</ul>
<p>判定即做两次网络流, 第一次不加先手点, 第二次加先手点, 看第二次流量会不会变大即可.</p>
<h2 id="最小点覆盖-最大独立集">最小点覆盖/最大独立集</h2>
<p>最小点覆盖 : 最少的点覆盖所有的边</p>
<p>最大独立集 : 最多的点, 互相之间没有边</p>
<ul>
<li>
<p><strong>Konig 定理</strong></p>
<p>最小点覆盖 = 最大匹配数</p>
<p>​	优先选择连接了非匹配点的匹配点</p>
<p>最大独立集 = 顶点数 - 最小点覆盖</p>
<p>​	把最小点覆盖的那些点拿掉, 剩下的点就是最大独立集</p>
</li>
<li>
<p>最小点(权)覆盖建模</p>
<p>中间的边容量无穷大, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到左边, 右边到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​ 的容量为1.   每条边都被左端点或者右端点覆盖 等价于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mi>u</mi><mo>−</mo><mi>v</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s-u-v-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的任意一条路径拿走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">s-u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">v-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</p>
</li>
<li>
<p>最大独立集建模</p>
<p>求出最小点覆盖之后取补集.</p>
</li>
</ul>
<h2 id="最大权匹配KM算法">最大权匹配KM算法</h2>
<p>复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 常数较小. 在费用流被卡的时候用.</p>
<p>该算法求的匹配必须是完备匹配, 所以本来没有的边我们在权值矩阵中设置为0即可, 这样不影响正常答案.</p>
<p>为了和我们加入的边区分, 最好加入的边加上一个offset以让所有边的权值都严格大于0, 这样有两个好处.</p>
<ol>
<li>
<p>可以输出方案.</p>
<p>在最后的匹配中扔掉权值为0的边即可.</p>
</li>
<li>
<p>可以处理负权值的边.</p>
<p>要把负权值的边加到正权值才能跑KM, 否则会被权值为0的虚边影响.</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> KuhnMunkras</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pre[V];      <span class="comment">// 增广路中右侧点的同侧前驱</span></span><br><span class="line">    <span class="keyword">int</span> linker[V];   <span class="comment">// 右边点的左侧匹配点</span></span><br><span class="line">    <span class="keyword">bool</span> vis[V];     <span class="comment">// 是否在增广路中</span></span><br><span class="line">    T g[V][V];       <span class="comment">// 权值图</span></span><br><span class="line">    T slack[V];      <span class="comment">// 右侧点的松弛值</span></span><br><span class="line">    T lx[V], ly[V];  <span class="comment">// 顶标</span></span><br><span class="line">    T offset = <span class="number">1e13</span>; <span class="comment">// 有负权值, 或者求最小权匹配需要把权值翻转,则需要把所有权值加到大于0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> n)</span> <span class="comment">// 增广树的根</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));        <span class="comment">// 右边同侧的前驱点</span></span><br><span class="line">        <span class="built_in">memset</span>(slack, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(slack)); <span class="comment">// 右边每个点需要松弛的最小值</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        linker[v] = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T delta = INF64;</span><br><span class="line">            <span class="keyword">int</span> u = linker[v]; <span class="comment">// v 的匹配点</span></span><br><span class="line">            <span class="keyword">int</span> next_v;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) <span class="comment">// 尝试为 u 找一条边加入子图</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (slack[i] &gt; lx[u] + ly[i] - g[u][i]) <span class="comment">// 更新右边每个点的最小松弛值</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        slack[i] = lx[u] + ly[i] - g[u][i];</span><br><span class="line">                        pre[i] = v;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (slack[i] &lt; delta) <span class="comment">// 更新全局最小松弛值. 如果slack是0说明边在里面,</span></span><br><span class="line">                        delta = slack[i], next_v = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, <span class="number">0</span>, n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[i]) <span class="comment">// v已经在增广路中了</span></span><br><span class="line">                    lx[linker[i]] -= delta, ly[i] += delta;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    slack[i] -= delta;</span><br><span class="line">            &#125;</span><br><span class="line">            v = next_v;</span><br><span class="line">            <span class="keyword">if</span> (!linker[v]) <span class="comment">// 找到了增广路</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (v) <span class="comment">// 增广路的边取反</span></span><br><span class="line">            linker[v] = linker[pre[v]], v = pre[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">match</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(linker, <span class="number">0</span>, <span class="keyword">sizeof</span>(linker));</span><br><span class="line">        <span class="built_in">memset</span>(lx, <span class="number">0</span>, <span class="keyword">sizeof</span>(lx));</span><br><span class="line">        <span class="built_in">memset</span>(ly, <span class="number">0</span>, <span class="keyword">sizeof</span>(ly));</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            bfs(i, n);</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (g[linker[i]][i] != <span class="number">0</span>)</span><br><span class="line">            res += g[linker[i]][i] - offset;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, T cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g[from][to] = offset + cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hall-定理">Hall 定理</h2>
<p>二分图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo>&lt;</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>E</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">G=  &lt;V_1,V_2, E&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>, 设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>V</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><msub><mi>V</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V_{1}| \le |V_{2}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>, 则存在完备匹配的条件是 对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的任意子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中和该子集相邻的点数大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span>.</p>
<ul>
<li>推论</li>
</ul>
<h1>连通性</h1>
<h2 id="最小生成树">最小生成树</h2>
<ol>
<li>
<p>环定理</p>
<p>对于连通图的任意一个环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ,  若其中存在一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> , 它的权值大于其他所有的边, 那么这条边一定不在最小生成树之中.</p>
</li>
<li>
<p>权值序列唯一</p>
<p>把最小生成树的边权从小到大排个序, 那么所有的最小生成树的序列都是相同的.</p>
</li>
<li>
<p>字典序最小</p>
<p>最小生成树的权值序列一定是所有生成树中字典序最小的.</p>
</li>
<li>
<p>不包含环上最大边</p>
<p>最小生成树不会包含一个环上所有最大值的边.</p>
</li>
<li>
<p>转换定理</p>
<p>则对于两颗不同的最小生成树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, 可以任意选择一条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 有而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 没有的边添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 中, 删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 中某条权值相同且不在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 中的边, 直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 完全相同.</p>
</li>
<li>
<p>连通性.</p>
<p>按照 <code>kruscal</code> 的过程, 处理完所有小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>​ 的权值的边后, 图的连通性是相同的</p>
</li>
<li>
<p>最小瓶颈生成树</p>
<p>最小瓶颈生成树中最大的边的边权在所有的生成树中最小. 最小生成树一定是最小瓶颈生成树.</p>
</li>
</ol>
<h2 id="有向图">有向图</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> scc &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], instack[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], s[N], tp;</span><br><span class="line"><span class="keyword">int</span> scc[N];   <span class="comment">/* 每个点所在的连通分量的编号 */</span></span><br><span class="line"><span class="keyword">int</span> szscc[N]; <span class="comment">/* 记录每个点所在的连通分量的大 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id, sc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  dfn[u] = ++id;</span><br><span class="line">  low[u] = dfn[u];</span><br><span class="line"></span><br><span class="line">  instack[u] = <span class="literal">true</span>;</span><br><span class="line">  s[++tp] = u;  <span class="comment">// 入栈</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) Dfs(v);</span><br><span class="line">    <span class="keyword">if</span> (instack[v]) low[u] = min(low[u], low[v]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">    sc++;  <span class="comment">//连通分量标号</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (x = s[tp])  <span class="comment">// 把连通分量从栈内搞出来</span></span><br><span class="line">    &#123;</span><br><span class="line">      scc[x] = sc;</span><br><span class="line">      szscc[sc]++;</span><br><span class="line">      tp--;</span><br><span class="line">      instack[x] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (x == u) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(instack, <span class="literal">false</span>, <span class="keyword">sizeof</span>(instack));</span><br><span class="line">  <span class="built_in">memset</span>(szscc, <span class="number">0</span>, <span class="keyword">sizeof</span>(szscc));</span><br><span class="line"></span><br><span class="line">  id = sc = tp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) Dfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace scc</span></span><br></pre></td></tr></table></figure>
<h2 id="无向图">无向图</h2>
<p>无向图DFS 树不存在横插边, 只有</p>
<ol>
<li>树边</li>
<li>返祖边</li>
</ol>
<p>用返祖边来判断割点和割边.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UndirectedGraph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[V];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> CutPoint</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low[V], dfn[V], _dfn;</span><br><span class="line">        <span class="keyword">bool</span> iscut[V];</span><br><span class="line">		<span class="keyword">int</span> numcut[V];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            dfn[u] = low[u] = ++_dfn;</span><br><span class="line">            <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dfn[v]) <span class="comment">// 树边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(v, u);</span><br><span class="line">                    low[u] = min(low[u], low[v]);</span><br><span class="line">                    <span class="keyword">if</span>(fa == <span class="number">0</span>)</span><br><span class="line">                        child++;</span><br><span class="line">                   	<span class="keyword">else</span> <span class="keyword">if</span>(low[v] &gt;= dfn[u])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 割掉 u 之后 这条边 下面 就是一个新的连通块</span></span><br><span class="line">                    	iscut[u] = <span class="number">1</span>; </span><br><span class="line">                        numcut[u]++;  <span class="comment">// 形成的连通块数量</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 否则这条边下面会和 u 上方连在一起</span></span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) <span class="comment">// 前向边或者返祖边</span></span><br><span class="line">                	low[u] = min(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fa == <span class="number">0</span> &amp;&amp; child &gt; <span class="number">1</span>)</span><br><span class="line">                iscut[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fa == <span class="number">0</span>)</span><br><span class="line">                numcut[u] == child; <span class="comment">// 根的连通块个数就是孩子的个数</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                numcut[u]++; <span class="comment">// 其余节点需要加上上方那个连通块</span></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 要注意题目有没有说初始联通</span></span><br><span class="line">            rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">                dfs(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有被返祖边覆盖的边就是桥</span></span><br><span class="line">    <span class="keyword">namespace</span> CutEdge</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>特殊图</h1>
<h2 id="竞赛图">竞赛图</h2>
<blockquote>
<p>https://www.cnblogs.com/LLCSBlog/p/14020151.html 竞赛图性质</p>
<p>https://blog.csdn.net/a_crazy_czy/article/details/73611366 兰道定理的证明</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 阶竞赛图是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点的有向完全图.</p>
<ol>
<li>
<p>竞赛图强连通缩点之后 DAG 呈链状, 前面的所有点向后面所有点连边.</p>
</li>
<li>
<p>竞赛图是强连通的等价于存在一条哈密顿回路.</p>
</li>
<li>
<p>竞赛图存在一条哈密顿路径.</p>
</li>
<li>
<p>竞赛图任意点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的强连通分量包含长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 的环.</p>
</li>
<li>
<p>竞赛图中出度最大的节点和所有节点的距离不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> .</p>
</li>
</ol>
<h3 id="Codeforces-1556-F-Sports-Betting">Codeforces 1556 F. Sports Betting</h3>
<ul>
<li>
<p>题意</p>
<p>给一张有向图, 每条边的方向有一个概率生成. 求竞赛图的第一个连通块的期望大小.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">n = 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span></span></span></span>.</p>
</li>
<li>
<p>分析</p>
<p>二进制枚举第一个连通块.</p>
<p>定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 子集强连通的概率. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 子集中每一个人击败 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 子集中每一个人的概率.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>​ 比较好算.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>​ 用容斥算. 枚举形成的竞赛图的第一个连通块的大小, 所有情况的概率和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><munder><mo>∑</mo><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mo>⊂</mo><mi>X</mi><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo mathvariant="normal">≠</mo><mi>x</mi></mrow></munder><mi>P</mi><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>G</mi><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo separator="true">,</mo><mi>X</mi><mo>∖</mo><mi>s</mi><mi>u</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X) = 1 - \sum_{sub \subset X, sub \neq x}P(sub) \cdot G(sub, X \setminus sub)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span><span class="mrel mtight">⊂</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">b</span><span class="mrel mtight"><span class="mrel mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="rlap mtight"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel mtight"></span></span><span class="fix"></span></span></span></span></span><span class="mrel mtight">=</span></span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span></p>
<p>最后答案又是类似上个式子右侧的求和.</p>
</li>
<li>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * x * y % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> ((x + y) % MOD + MOD) % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> ((x - y) % MOD + MOD) % MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = mul(ans, a);</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QWQ</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>], g[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QWQ</span></span><br><span class="line">    <span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">int</span> st_cl = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QWQ</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    rep(i, <span class="number">0</span>, n - <span class="number">1</span>) rep(j, <span class="number">0</span>, n - <span class="number">1</span>) g[i][j] = mul(a[i], qpow(a[i] + a[j], MOD - <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">    rep(i, <span class="number">1</span>, m - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>) &amp; i; j; j = (j - <span class="number">1</span>) &amp; i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            rep(l1, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j &gt;&gt; l1) &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    rep(l2, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!((j &gt;&gt; l2) &amp; <span class="number">1</span>) &amp;&amp; ((i &gt;&gt; l2) &amp; <span class="number">1</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            sum = mul(sum, g[l1][l2]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = sub(f[i], mul(f[j], sum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, m - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        rep(l1, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; l1) &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rep(l2, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!((i &gt;&gt; l2) &amp; <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum = mul(sum, g[l1][l2]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = mul(__builtin_popcount(i), mul(f[i], sum));</span><br><span class="line">        ans = add(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QWQ</span></span><br><span class="line">    LOG(<span class="string">&quot;Time: %dms\n&quot;</span>, <span class="keyword">int</span>((clock() - st_cl) / (<span class="keyword">double</span>)CLOCKS_PER_SEC * <span class="number">1000</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&amp;Lowell.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ACM/Template/ACM/Template/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"><img class="prev-cover" data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Daft%20Punk_Random%20Access%20Memories.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算几何</div></div></a></div><div class="next-post pull-right"><a href="/ACM/Template/ACM/Template/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"><img class="next-cover" data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Daft%20Punk_Random%20Access%20Memories.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树上问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/qwq_circle2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">qwqbot</div><div class="author-info__description">CS-ACM-MUSIC-REANGDING-MOVIE</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pwqbot"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:974314484@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">最大流&#x2F;最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dinic"><span class="toc-text">Dinic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E8%BE%B9-%E5%BF%85%E9%A1%BB%E8%BE%B9"><span class="toc-text">可行边&#x2F;必须边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE"><span class="toc-text">平面图转对偶图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE"><span class="toc-text">最大权闭合子图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7-%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">洛谷 太空飞行计划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text">上下界网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-text">无源汇上下界可行流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E5%8F%AF%E8%A1%8C%E6%B5%81"><span class="toc-text">有源汇上下界可行流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最大流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%B5%81"><span class="toc-text">最小流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%AF%E5%BD%A2"><span class="toc-text">单纯形</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88"><span class="toc-text">二分图博弈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96-%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="toc-text">最小点覆盖&#x2F;最大独立集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8DKM%E7%AE%97%E6%B3%95"><span class="toc-text">最大权匹配KM算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hall-%E5%AE%9A%E7%90%86"><span class="toc-text">Hall 定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-text">无向图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">特殊图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE"><span class="toc-text">竞赛图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Codeforces-1556-F-Sports-Betting"><span class="toc-text">Codeforces 1556 F. Sports Betting</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最近更新</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/C/CS0804n/C/Cmake/" title="CMake 中的继承关系"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&amp;Lowell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake 中的继承关系"/></a><div class="content"><a class="title" href="/CS0804n/C/CS0804n/C/Cmake/" title="CMake 中的继承关系">CMake 中的继承关系</a><time datetime="2021-12-12T12:43:58.094Z" title="更新于 2021-12-12 20:43:58">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/C/CS0804n/C/inline%20function/" title="inline function linkage in C"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/James%20Blake_Are%20you%20even%20Real.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="inline function linkage in C"/></a><div class="content"><a class="title" href="/CS0804n/C/CS0804n/C/inline%20function/" title="inline function linkage in C">inline function linkage in C</a><time datetime="2021-12-12T11:26:40.693Z" title="更新于 2021-12-12 19:26:40">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/Linux/CS0804n/Linux/%E7%BB%88%E7%AB%AF%E5%92%8Cshell/" title="无题"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Snipaste_2021-05-02_20-52-58.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/CS0804n/Linux/CS0804n/Linux/%E7%BB%88%E7%AB%AF%E5%92%8Cshell/" title="无题">无题</a><time datetime="2021-12-12T11:24:35.555Z" title="更新于 2021-12-12 19:24:35">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ACM/ACM/%E6%95%B0%E4%BD%8Ddp%E6%80%BB%E7%BB%93/" title="无题"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/%E6%9B%BE%E8%BD%B6%E5%8F%AF_%E9%9B%8C%E9%9B%84%E5%90%8C%E4%BD%93.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/ACM/ACM/%E6%95%B0%E4%BD%8Ddp%E6%80%BB%E7%BB%93/" title="无题">无题</a><time datetime="2021-12-12T11:24:35.555Z" title="更新于 2021-12-12 19:24:35">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/CS0804n/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20%E4%BD%9C%E4%B8%9A1/" title="无题"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/%E7%A6%8F%E7%A6%84%E5%AF%BF_%E6%88%91%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%8A%E4%BD%A0%E7%95%99%E4%BD%8F.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/CS0804n/CS0804n/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20%E4%BD%9C%E4%B8%9A1/" title="无题">无题</a><time datetime="2021-12-12T11:24:35.555Z" title="更新于 2021-12-12 19:24:35">2021-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By qwqbot</div><div class="footer_custom_text">福禄寿伴你左右</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>