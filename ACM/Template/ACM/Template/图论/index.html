<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>图论 | qwqbot</title><meta name="author" content="qwqbot"><meta name="copyright" content="qwqbot"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络流 最大流&#x2F;最小割 Dinic namespace Dinic&amp;#123;    using T &#x3D; long long;    const int EDGE &#x3D; 600005;    const int V &#x3D; 2005;    struct Edge    &amp;#123;        int next, to;        T cap;    &amp;#125; e[EDGE];    int">
<meta property="og:type" content="article">
<meta property="og:title" content="图论">
<meta property="og:url" content="http://qwqbot.com/ACM/Template/ACM/Template/%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="qwqbot">
<meta property="og:description" content="网络流 最大流&#x2F;最小割 Dinic namespace Dinic&amp;#123;    using T &#x3D; long long;    const int EDGE &#x3D; 600005;    const int V &#x3D; 2005;    struct Edge    &amp;#123;        int next, to;        T cap;    &amp;#125; e[EDGE];    int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/James%20Blake_Are%20you%20even%20Real.jpg">
<meta property="article:published_time" content="2021-07-31T03:52:15.432Z">
<meta property="article:modified_time" content="2021-10-06T12:54:41.890Z">
<meta property="article:author" content="qwqbot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/James%20Blake_Are%20you%20even%20Real.jpg"><link rel="shortcut icon" href="/img/qwq_circle2.jpg"><link rel="canonical" href="http://qwqbot.com/ACM/Template/ACM/Template/%E5%9B%BE%E8%AE%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-06 20:54:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/qwq_circle2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ding-typora.oss-cn-beijing.aliyuncs.com/img/James%20Blake_Are%20you%20even%20Real.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qwqbot</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-31T03:52:15.432Z" title="发表于 2021-07-31 11:52:15">2021-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-06T12:54:41.890Z" title="更新于 2021-10-06 20:54:41">2021-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/">ACM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ACM/Template/">Template</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>网络流</h1>
<h2 id="最大流-最小割">最大流/最小割</h2>
<h3 id="Dinic">Dinic</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Dinic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> EDGE = <span class="number">600005</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> next, to;</span><br><span class="line">        T cap;</span><br><span class="line">    &#125; e[EDGE];</span><br><span class="line">    <span class="keyword">int</span> cnt, head[V], cur[V];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d[V];	</span><br><span class="line">    <span class="keyword">int</span> pre[V];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, T cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        e[cnt].to = to, e[cnt].cap = cap, e[cnt].next = head[from];</span><br><span class="line">        head[from] = cnt++;</span><br><span class="line">        e[cnt].to = from, e[cnt].cap = <span class="number">0</span>, e[cnt].next = head[to];</span><br><span class="line">        head[to] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> <span class="comment">//建图</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> <span class="comment">//对残留网络分层</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">        Q.push(s);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        pre[s] = pre[t] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i != <span class="number">-1</span>; i = e[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">                <span class="keyword">if</span> (e[i].cap &amp;&amp; d[to] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre[to] = i;</span><br><span class="line">                    d[to] = d[now] + <span class="number">1</span>;</span><br><span class="line">                    Q.push(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[t] != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路增广, 适用于稠密图</span></span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t, T limit)</span> <span class="comment">//在一条路上,limit是单调递减的</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!limit || x == t) <span class="comment">// 如果限制为0了, 或者到t了返回</span></span><br><span class="line">            <span class="keyword">return</span> limit;</span><br><span class="line">        T flow = <span class="number">0</span>, nf = <span class="number">0</span>; <span class="comment">// flow 是当前点后面总共的流量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span>; i = e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur[x] = i; <span class="comment">//当前弧优化. 如果这次跑到了这条弧, 那么下一次从这条开始即可, 因为之前都跑满了.</span></span><br><span class="line">            <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[to] == d[x] + <span class="number">1</span> &amp;&amp; e[i].cap &amp;&amp; (nf = dfs(to, t, min(limit, e[i].cap))))</span><br><span class="line">            &#123;</span><br><span class="line">                limit -= nf;</span><br><span class="line">                flow += nf;</span><br><span class="line">                e[i].cap -= nf;</span><br><span class="line">                e[i ^ <span class="number">1</span>].cap += nf;</span><br><span class="line">                <span class="keyword">if</span> (!limit)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单路增广, 适用于边容量很小的图</span></span><br><span class="line">    <span class="function">T <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T limit = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to])</span><br><span class="line">            limit = min(limit, e[pe].cap);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to])</span><br><span class="line">        &#123;</span><br><span class="line">            e[pe].cap -= limit;</span><br><span class="line">            e[pe ^ <span class="number">1</span>].cap += limit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs(s, t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// dinic 算法</span></span><br><span class="line">            <span class="comment">// ans += dfs(s, t, 0x3f3f3f3f3f3f3f3f);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// EK 算法</span></span><br><span class="line">            ans += ek(s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; <span class="comment">// ans是最大流, res 才是费用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最小割">最小割</h2>
<p>割的两种表述:</p>
<ol>
<li>割是一些边集, 拿走这些边之后不存在一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>​ 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​​​ 的路径.  也就是任意一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>​ 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​ 的路径, 至少有一条边在割中.</li>
<li>割是把所有点分成两个点集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>. 其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</li>
</ol>
<p>最小割是所有割中容量最小的割.</p>
<ul>
<li>
<p>最大流最小割定理</p>
<p>最大流等于最小割. 此时图中不存在一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的路径.</p>
</li>
<li>
<p>最小割方案</p>
<p>跑完网络流之后, 看 <code>bfs</code> 的距离数组中距离不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的边, 即为割点集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中的点的连出这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的并且满流的边就是割边.</p>
</li>
</ul>
<h3 id="可行边-必须边">可行边/必须边</h3>
<ul>
<li>
<p>最小割可行边 = 最大流一定满流的边</p>
<p>边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 被某个最小割包含, 等价于 减小该边的容量之后 最小割减小(即最大流也一定减小)</p>
<ol>
<li>满流</li>
<li>在残留网络中, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>​ 不在一个强连通分量中</li>
</ol>
<p>注意只判断第二个条件是不够的, 因为没有满流可能是空流, 那么此时第二个条件也会满足.</p>
</li>
<li>
<p>最小割必须边</p>
<p>边 $(u,v) $ 在所有最小割中, 必须满足增大该边的容量之后最小割增大.</p>
<ol>
<li>满流</li>
<li>在残留网络中, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 可以到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 可以到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</li>
</ol>
<p>第二条件等价于判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 在一个强连通分量, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 在一个强连通分量.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tarjan</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// const int V = ;</span></span><br><span class="line">    <span class="keyword">bool</span> instack[V];</span><br><span class="line">    <span class="keyword">int</span> scc[V], szscc[V], _sc;</span><br><span class="line">    <span class="keyword">int</span> dfn[V], low[V], _dfn;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[u] = ++_dfn;</span><br><span class="line">        low[u] = dfn[u];</span><br><span class="line">        instack[u] = <span class="literal">true</span>;</span><br><span class="line">        s.push(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].cap == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">                dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (instack[v])</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u])</span><br><span class="line">        &#123;</span><br><span class="line">            _sc++;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                scc[x] = _sc;</span><br><span class="line">                szscc[x]++;</span><br><span class="line">                instack[x] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SCC</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line">Dinic::e[(i - <span class="number">1</span>) * <span class="number">2</span>].cap != <span class="number">0</span></span><br><span class="line">Dinic::Tarjan::scc[u] != Dinic::Tarjan::scc[v]</span><br><span class="line">(Dinic::Tarjan::scc[s] == Dinic::Tarjan::scc[u]) &amp;&amp; (Dinic::Tarjan::scc[t] == Dinic::Tarjan::scc[v])</span><br></pre></td></tr></table></figure>
<h3 id="平面图转对偶图">平面图转对偶图</h3>
<h2 id="最小费用最大流">最小费用最大流</h2>
<ul>
<li>
<p><code>spfa</code> 版本</p>
<p>多路增广的适合流量大的时候.</p>
<p>单路增广的适合流量小的时候.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> dinic &#123;</span><br><span class="line"><span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">605</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> EDGE = V * V + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> next, to;</span><br><span class="line">  <span class="keyword">int</span> cap;</span><br><span class="line">  T cost;</span><br><span class="line">&#125; e[EDGE];</span><br><span class="line"><span class="keyword">int</span> cnt, head[V];</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;  <span class="comment">// spfa</span></span><br><span class="line"><span class="keyword">bool</span> vis[V];   <span class="comment">// spfa(不需memset) 和 dfs避免环</span></span><br><span class="line"><span class="keyword">int</span> pre[V];    <span class="comment">// 记录点的前驱边</span></span><br><span class="line">T d[V];        <span class="comment">// 距离</span></span><br><span class="line">T res;         <span class="comment">//记录费用</span></span><br><span class="line"><span class="keyword">int</span> cur[V];    <span class="comment">// dinic 算法的当前弧优化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, T cost)</span> </span>&#123;</span><br><span class="line">  e[cnt].to = to, e[cnt].cap = cap, e[cnt].cost = cost,</span><br><span class="line">  e[cnt].next = head[from];</span><br><span class="line">  head[from] = cnt++;</span><br><span class="line">  e[cnt].to = from, e[cnt].cap = <span class="number">0</span>, e[cnt].cost = -cost, e[cnt].next = head[to];</span><br><span class="line">  head[to] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span>  <span class="comment">//建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res = cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  <span class="comment">//对残留网络分层</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dinic 的当前弧优化</span></span><br><span class="line">  <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// EK 算法</span></span><br><span class="line">  pre[s] = pre[t] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  Q.push_back(s);</span><br><span class="line">  d[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> now = Q.front();</span><br><span class="line">    Q.pop_front();</span><br><span class="line">    vis[now] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e[i].cap == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (d[to] &gt; d[now] + e[i].cost) &#123;</span><br><span class="line">        d[to] = d[now] + e[i].cost;</span><br><span class="line">        pre[to] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to])  <span class="comment">// 不在队列里则加入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[to] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (Q.empty() || d[to] &lt; d[Q.front()])  <span class="comment">// SLF优化</span></span><br><span class="line">            Q.push_front(to);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            Q.push_back(to);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre[t] != <span class="number">-1</span>;  <span class="comment">// 从 s 到 t 是否存在一条路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多路增广, 适用于稠密图</span></span><br><span class="line"><span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t, <span class="keyword">int</span> limit)</span>  <span class="comment">//在一条路上,limit是单调递减的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!limit || x == t)  <span class="comment">// 如果限制为0了, 或者到t了返回</span></span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">  <span class="keyword">int</span> flow = <span class="number">0</span>, nf = <span class="number">0</span>;  <span class="comment">// flow 是当前点后面总共的流量</span></span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">    cur[x] = i;  <span class="comment">//当前弧优化. 如果这次跑到了这条弧, 那么下一次从这条开始即可,</span></span><br><span class="line">                 <span class="comment">//因为之前都跑满了.</span></span><br><span class="line">    <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (vis[to])  <span class="comment">//这步是为了防止有费用为0的边出现的环</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[to] == d[x] + e[i].cost &amp;&amp; e[i].cap &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (nf = dfs(to, t, min(limit, e[i].cap)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nf)  <span class="comment">// 如果还可以流</span></span><br><span class="line">        res += nf * e[i].cost;</span><br><span class="line">      limit -= nf;</span><br><span class="line">      flow += nf;</span><br><span class="line">      e[i].cap -= nf;</span><br><span class="line">      e[i ^ <span class="number">1</span>].cap += nf;</span><br><span class="line">      <span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[x] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单路增广, 适用于边容量很小的图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> limit = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to])  <span class="comment">// 找瓶颈边</span></span><br><span class="line">    limit = min(limit, e[pe].cap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pe = pre[t]; pe != <span class="number">-1</span>; pe = pre[e[pe ^ <span class="number">1</span>].to]) &#123;</span><br><span class="line">    res += e[pe].cost * limit;</span><br><span class="line">    e[pe].cap -= limit;</span><br><span class="line">    e[pe ^ <span class="number">1</span>].cap += limit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;T, T&gt; flow(int s, int t) &#123;</span><br><span class="line">  T ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (spfa(s, t)) &#123;</span><br><span class="line">    <span class="comment">// 多路增广</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    ans += dfs(s, t, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单路增广</span></span><br><span class="line">    ans += ek(s, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;ans, res&#125;;  <span class="comment">// ans:最大流, res:费用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;  <span class="comment">// namespace dinic</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dijkstra</code> 版本</p>
<p>咕了</p>
</li>
</ul>
<h2 id="最大权闭合子图">最大权闭合子图</h2>
<ul>
<li>
<p>建模</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 连向正权点, 容量为点权. 负权点连向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> , 容量为点权的绝对值. 原图边的容量设置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></p>
<p>这样一个点如果选了, 即在割集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中, 那么他连向的点都要在割集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中​.</p>
<p>这样建模之后是一个类似二分图的东西, 割边只能是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 连出来的边和连向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的边.</p>
</li>
<li>
<p>答案</p>
<p>最大权闭合子图是所有<strong>正点权</strong>和减去最小割.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><msup><mi>w</mi><mo lspace="0em" rspace="0em">+</mo></msup><mo>−</mo><mi>c</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(V&#x27;)  = \sum w^{+} - c(S,T)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></span></p>
<p>方案是割集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>.</p>
</li>
</ul>
<h1>二分图</h1>
<ul>
<li>
<p>判定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">void</span> dfs(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    col[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[v] == <span class="number">-1</span>)</span><br><span class="line">            dfs(v, c ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (col[v] == col[u])</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>增广路</p>
<p>起点和终点都是非匹配点, 并且走的边是 非 - 匹 - 非 …. 非.</p>
<p>把增广路中所有的非匹配边换成匹配边, 匹配边换成非匹配边, 仍然是一个匹配, 并且匹配数量加1.</p>
<ol>
<li>有奇数条边. 奇数边是非匹配边.</li>
</ol>
</li>
</ul>
<h2 id="二分图博弈">二分图博弈</h2>
<p>这里假设先手在左边, 后手在右边.</p>
<ul>
<li>
<p>先手点若<strong>一定在最大匹配内</strong>, 则先手必胜.</p>
<p>从先手点开始走 匹配边 - 非匹配边 - 匹配边 - …..  最后一定停在右边. 如果停在左边, 路径上匹配边和非匹配边数量相同, 取反后获得一个不包含先手点的最大匹配, 和前提矛盾</p>
</li>
<li>
<p>若<strong>存在</strong>一个最大匹配, <strong>不包含先手点</strong>, 则先手必败.</p>
<p>在该最大匹配中, 先手点走的增广路只能先走非匹配边, 然后后手选择走匹配边, 这样  非 - 匹 - 非 ….. 匹, 最后一条边是匹配边, 否则会得到一个更大的匹配. 所以最后停在左边.</p>
</li>
</ul>
<h2 id="最小点覆盖-最大独立集">最小点覆盖/最大独立集</h2>
<p>最小点覆盖 : 最少的点覆盖所有的边</p>
<p>最大独立集 : 最多的点, 互相之间没有边</p>
<ul>
<li>
<p><strong>Konig 定理</strong></p>
<p>最小点覆盖 = 最大匹配数</p>
<p>​	优先选择连接了非匹配点的匹配点</p>
<p>最大独立集 = 顶点数 - 最小点覆盖</p>
<p>​	把最小点覆盖的那些点拿掉, 剩下的点就是最大独立集</p>
</li>
<li>
<p>最小点(权)覆盖建模</p>
<p>中间的边容量无穷大, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到左边, 右边到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>​ 的容量为1.   每条边都被左端点或者右端点覆盖 等价于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mi>u</mi><mo>−</mo><mi>v</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s-u-v-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> 的任意一条路径拿走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>−</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">s-u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">v-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>.</p>
</li>
<li>
<p>最大独立集建模</p>
<p>求出最小点覆盖之后取补集.</p>
</li>
</ul>
<h2 id="最大权匹配KM算法">最大权匹配KM算法</h2>
<p>复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 常数较小. 在费用流被卡的时候用.</p>
<p>该算法求的匹配必须是完备匹配, 所以本来没有的边我们在权值矩阵中设置为0即可, 这样不影响正常答案.</p>
<p>为了和我们加入的边区分, 最好加入的边加上一个offset以让所有边的权值都严格大于0, 这样有两个好处.</p>
<ol>
<li>
<p>可以输出方案.</p>
<p>在最后的匹配中扔掉权值为0的边即可.</p>
</li>
<li>
<p>可以处理负权值的边.</p>
<p>要把负权值的边加到正权值才能跑KM, 否则会被权值为0的虚边影响.</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> KuhnMunkras</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pre[V];      <span class="comment">// 增广路中右侧点的同侧前驱</span></span><br><span class="line">    <span class="keyword">int</span> linker[V];   <span class="comment">// 右边点的左侧匹配点</span></span><br><span class="line">    <span class="keyword">bool</span> vis[V];     <span class="comment">// 是否在增广路中</span></span><br><span class="line">    T g[V][V];       <span class="comment">// 权值图</span></span><br><span class="line">    T slack[V];      <span class="comment">// 右侧点的松弛值</span></span><br><span class="line">    T lx[V], ly[V];  <span class="comment">// 顶标</span></span><br><span class="line">    T offset = <span class="number">1e13</span>; <span class="comment">// 有负权值, 或者求最小权匹配需要把权值翻转,则需要把所有权值加到大于0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> n)</span> <span class="comment">// 增广树的根</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));        <span class="comment">// 右边同侧的前驱点</span></span><br><span class="line">        <span class="built_in">memset</span>(slack, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(slack)); <span class="comment">// 右边每个点需要松弛的最小值</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        linker[v] = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T delta = INF64;</span><br><span class="line">            <span class="keyword">int</span> u = linker[v]; <span class="comment">// v 的匹配点</span></span><br><span class="line">            <span class="keyword">int</span> next_v;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            rep(i, <span class="number">1</span>, n) <span class="comment">// 尝试为 u 找一条边加入子图</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (slack[i] &gt; lx[u] + ly[i] - g[u][i]) <span class="comment">// 更新右边每个点的最小松弛值</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        slack[i] = lx[u] + ly[i] - g[u][i];</span><br><span class="line">                        pre[i] = v;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (slack[i] &lt; delta) <span class="comment">// 更新全局最小松弛值. 如果slack是0说明边在里面,</span></span><br><span class="line">                        delta = slack[i], next_v = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rep(i, <span class="number">0</span>, n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[i]) <span class="comment">// v已经在增广路中了</span></span><br><span class="line">                    lx[linker[i]] -= delta, ly[i] += delta;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    slack[i] -= delta;</span><br><span class="line">            &#125;</span><br><span class="line">            v = next_v;</span><br><span class="line">            <span class="keyword">if</span> (!linker[v]) <span class="comment">// 找到了增广路</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (v) <span class="comment">// 增广路的边取反</span></span><br><span class="line">            linker[v] = linker[pre[v]], v = pre[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">match</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(linker, <span class="number">0</span>, <span class="keyword">sizeof</span>(linker));</span><br><span class="line">        <span class="built_in">memset</span>(lx, <span class="number">0</span>, <span class="keyword">sizeof</span>(lx));</span><br><span class="line">        <span class="built_in">memset</span>(ly, <span class="number">0</span>, <span class="keyword">sizeof</span>(ly));</span><br><span class="line"></span><br><span class="line">        rep(i, <span class="number">1</span>, n)</span><br><span class="line">            bfs(i, n);</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (g[linker[i]][i] != <span class="number">0</span>)</span><br><span class="line">            res += g[linker[i]][i] - offset;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, T cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g[from][to] = offset + cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hall-定理">Hall 定理</h2>
<p>二分图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo>&lt;</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>E</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">G=  &lt;V_1,V_2, E&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>, 设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>V</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><msub><mi>V</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V_{1}| \le |V_{2}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>, 则存在完备匹配的条件是 对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的任意子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中和该子集相邻的点数大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span>.</p>
<ul>
<li>推论</li>
</ul>
<h1>连通性</h1>
<h2 id="最小生成树">最小生成树</h2>
<ol>
<li>
<p>环定理</p>
<p>对于连通图的任意一个环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ,  若其中存在一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> , 它的权值大于其他所有的边, 那么这条边一定不在最小生成树之中.</p>
</li>
<li>
<p>权值序列唯一</p>
<p>把最小生成树的边权从小到大排个序, 那么所有的最小生成树的序列都是相同的.</p>
</li>
<li>
<p>字典序最小</p>
<p>最小生成树的权值序列一定是所有生成树中字典序最小的.</p>
</li>
<li>
<p>不包含环上最大边</p>
<p>最小生成树不会包含一个环上所有最大值的边.</p>
</li>
<li>
<p>转换定理</p>
<p>则对于两颗不同的最小生成树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, 可以任意选择一条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 有而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 没有的边添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 中, 删除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 中某条权值相同且不在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 中的边, 直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 完全相同.</p>
</li>
<li>
<p>连通性.</p>
<p>按照 <code>kruscal</code> 的过程, 处理完所有小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 的权值的边后, 图的连通性是相同的.</p>
</li>
</ol>
<h2 id="有向图">有向图</h2>
<p>​</p>
<h2 id="无向图">无向图</h2>
<p>无向图DFS 树不存在横插边, 只有</p>
<ol>
<li>树边</li>
<li>返祖边</li>
</ol>
<p>用返祖边来判断割点和割边.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UndirectedGraph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[V];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> CutPoint</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low[V], dfn[V], _dfn;</span><br><span class="line">        <span class="keyword">bool</span> iscut[V];</span><br><span class="line">		<span class="keyword">int</span> numcut[V];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            dfn[u] = low[u] = ++_dfn;</span><br><span class="line">            <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dfn[v]) <span class="comment">// 树边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(v, u);</span><br><span class="line">                    low[u] = min(low[u], low[v]);</span><br><span class="line">                    <span class="keyword">if</span>(fa == <span class="number">0</span>)</span><br><span class="line">                        child++;</span><br><span class="line">                   	<span class="keyword">else</span> <span class="keyword">if</span>(low[v] &gt;= dfn[u])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 割掉 u 之后 这条边 下面 就是一个新的连通块</span></span><br><span class="line">                    	iscut[u] = <span class="number">1</span>; </span><br><span class="line">                        numcut[u]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 否则这条边下面会和 u 上方连在一起</span></span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) <span class="comment">// 前向边或者返祖边</span></span><br><span class="line">                	low[u] = min(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fa == <span class="number">0</span> &amp;&amp; child &gt; <span class="number">1</span>)</span><br><span class="line">                iscut[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fa == <span class="number">0</span>)</span><br><span class="line">                numcut[u] == child; <span class="comment">// 根的连通块个数就是孩子的个数</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                numcut[u]++; <span class="comment">// 其余节点需要加上上方那个连通块</span></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 要注意题目有没有说初始联通</span></span><br><span class="line">            rep(i, <span class="number">1</span>, n) <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">                dfs(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有被返祖边覆盖的边就是桥</span></span><br><span class="line">    <span class="keyword">namespace</span> CutEdge</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>特殊图</h1>
<h2 id="竞赛图">竞赛图</h2>
<blockquote>
<p>https://www.cnblogs.com/LLCSBlog/p/14020151.html 竞赛图性质</p>
<p>https://blog.csdn.net/a_crazy_czy/article/details/73611366 兰道定理的证明</p>
</blockquote>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 阶竞赛图是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点的有向完全图.</p>
<ol>
<li>
<p>竞赛图强连通缩点之后 DAG 呈链状, 前面的所有点向后面所有点连边.</p>
</li>
<li>
<p>竞赛图是强连通的等价于存在一条哈密顿回路.</p>
</li>
<li>
<p>竞赛图存在一条哈密顿路径.</p>
</li>
<li>
<p>竞赛图任意点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的强连通分量包含长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> 的环.</p>
</li>
<li>
<p>竞赛图中出度最大的节点和所有节点的距离不超过2.</p>
</li>
</ol>
<ul>
<li>兰道定理</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/James%20Blake_Are%20you%20even%20Real.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ACM/Template/ACM/Template/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"><img class="prev-cover" data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&amp;Lowell.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算几何</div></div></a></div><div class="next-post pull-right"><a href="/ACM/Template/ACM/Template/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"><img class="next-cover" data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/%E7%A6%8F%E7%A6%84%E5%AF%BF_%E6%88%91%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%8A%E4%BD%A0%E7%95%99%E4%BD%8F(%E4%B8%93%E8%BE%91).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树上问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/qwq_circle2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">qwqbot</div><div class="author-info__description">CS-ACM-MUSIC-REANGDING-MOVIE</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pwqbot"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:974314484@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">最大流&#x2F;最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dinic"><span class="toc-text">Dinic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-text">最小割</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E8%BE%B9-%E5%BF%85%E9%A1%BB%E8%BE%B9"><span class="toc-text">可行边&#x2F;必须边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%9B%BE%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE"><span class="toc-text">平面图转对偶图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE"><span class="toc-text">最大权闭合子图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88"><span class="toc-text">二分图博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%82%B9%E8%A6%86%E7%9B%96-%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="toc-text">最小点覆盖&#x2F;最大独立集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8DKM%E7%AE%97%E6%B3%95"><span class="toc-text">最大权匹配KM算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hall-%E5%AE%9A%E7%90%86"><span class="toc-text">Hall 定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">有向图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-text">无向图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">特殊图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%9E%E8%B5%9B%E5%9B%BE"><span class="toc-text">竞赛图</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最近更新</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/Tools/CS0804n/Tools/vim/" title="vim 备忘录"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/%E4%B8%87%E8%83%BD%E9%9D%92%E5%B9%B4%E6%97%85%E5%BA%97_%E6%99%8B%E8%A5%BF%E5%8D%97%E6%9E%97%E8%B7%AF%E8%A1%8C.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vim 备忘录"/></a><div class="content"><a class="title" href="/CS0804n/Tools/CS0804n/Tools/vim/" title="vim 备忘录">vim 备忘录</a><time datetime="2021-10-09T14:59:56.617Z" title="更新于 2021-10-09 22:59:56">2021-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/gdb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/" title="gdb调试命令"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/%E6%9B%BE%E8%BD%B6%E5%8F%AF_anti-yico!.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="gdb调试命令"/></a><div class="content"><a class="title" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/gdb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/" title="gdb调试命令">gdb调试命令</a><time datetime="2021-10-09T09:35:17.829Z" title="更新于 2021-10-09 17:35:17">2021-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab3/" title="ucore - Lab3 虚拟内存管理"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Manchester%20by%20the%20Sea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ucore - Lab3 虚拟内存管理"/></a><div class="content"><a class="title" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab3/" title="ucore - Lab3 虚拟内存管理">ucore - Lab3 虚拟内存管理</a><time datetime="2021-10-09T09:34:51.819Z" title="更新于 2021-10-09 17:34:51">2021-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab2/" title="ucore - Lab2 物理内存管理"><img data-lazy-src="https://ding-typora.oss-cn-beijing.aliyuncs.com/img/Sufjan%20Stevens_Carrie&amp;Lowell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ucore - Lab2 物理内存管理"/></a><div class="content"><a class="title" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab2/" title="ucore - Lab2 物理内存管理">ucore - Lab2 物理内存管理</a><time datetime="2021-10-09T09:34:49.836Z" title="更新于 2021-10-09 17:34:49">2021-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab1/" title="ucore - Lab1 系统软件的启动过程"><img data-lazy-src="http://ding-typora.oss-cn-beijing.aliyuncs.com/img/20130916100832359" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ucore - Lab1 系统软件的启动过程"/></a><div class="content"><a class="title" href="/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/CS0804n/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/Lab1/" title="ucore - Lab1 系统软件的启动过程">ucore - Lab1 系统软件的启动过程</a><time datetime="2021-10-09T09:34:47.464Z" title="更新于 2021-10-09 17:34:47">2021-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By qwqbot</div><div class="footer_custom_text">福禄寿伴你左右</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>